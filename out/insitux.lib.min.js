(()=>{"use strict";var e={d:(t,r)=>{for(var n in r)e.o(r,n)&&!e.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:r[n]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.d(t,{invoker:()=>yr});var r={};e.r(r),e.d(r,{abs:()=>S,acos:()=>K,asin:()=>W,atan:()=>z,ceil:()=>G,charCode:()=>I,codeChar:()=>P,concat:()=>h,cos:()=>F,cosh:()=>L,ends:()=>y,flat:()=>x,floor:()=>Y,getTimeMs:()=>N,has:()=>m,isArray:()=>u,isNum:()=>i,len:()=>o,log10:()=>ee,log2:()=>Z,logn:()=>Q,lowerCase:()=>C,max:()=>T,min:()=>q,objKeys:()=>H,padEnd:()=>E,push:()=>b,randInt:()=>j,randNum:()=>M,range:()=>D,reverse:()=>A,round:()=>X,sign:()=>J,sin:()=>O,sinh:()=>R,slen:()=>c,slice:()=>a,sortBy:()=>g,splice:()=>s,sqrt:()=>U,starts:()=>f,strIdx:()=>v,sub:()=>d,subIdx:()=>p,substr:()=>l,tan:()=>_,tanh:()=>V,toNum:()=>n,trim:()=>$,trimEnd:()=>B,trimStart:()=>w,upperCase:()=>k});const n=e=>Number(e),a=(e,t,r)=>e.slice(t,r),s=(e,t,r)=>e.splice(t,r),o=e=>e.length,c=e=>e.length,i=e=>!Number.isNaN(Number(e)),u=e=>Array.isArray(e),l=(e,t,r)=>e.substring(t,t+(r??e.length)),v=(e,t)=>e[t],d=(e,t)=>e.includes(t),p=(e,t)=>e.indexOf(t),m=(e,t)=>e.includes(t),f=(e,t)=>e.startsWith(t),y=(e,t)=>e.endsWith(t),x=e=>e.flat(),h=(e,t)=>e.concat(t),b=(e,t)=>e.push(...t),g=(e,t)=>e.sort(t),A=e=>e.reverse(),C=e=>e.toLowerCase(),k=e=>e.toUpperCase(),$=e=>e.trim(),w=e=>e.trimStart(),B=e=>e.trimEnd(),E=(e,t)=>e.padEnd(t),I=e=>e.charCodeAt(0),P=e=>String.fromCharCode(e),M=(e,t)=>e+Math.random()*(t-e),j=(e,t)=>Math.floor(M(e,t)),D=e=>[...Array(e).keys()],H=e=>Object.keys(e),N=()=>(new Date).getTime(),S=Math.abs,q=Math.min,T=Math.max,O=Math.sin,F=Math.cos,_=Math.tan,R=Math.sinh,L=Math.cosh,V=Math.tanh,W=Math.asin,K=Math.acos,z=Math.atan,U=Math.sqrt,X=Math.round,Y=Math.floor,G=Math.ceil,J=Math.sign,Q=Math.log,Z=Math.log2,ee=Math.log10,te={print:{returns:["null"]},"print-str":{returns:["null"]},"!":{exactArity:1,returns:["bool"]},"=":{minArity:2},"!=":{minArity:2},"+":{minArity:2,numeric:!0},"-":{minArity:1,numeric:!0},"*":{minArity:2,numeric:!0},"/":{minArity:2,numeric:!0},"//":{minArity:2,numeric:!0},"**":{minArity:1,maxArity:2,numeric:!0},"<":{minArity:2,numeric:!0},">":{minArity:2,numeric:!0},"<=":{minArity:2,numeric:!0},">=":{minArity:2,numeric:!0},"fast=":{exactArity:2},"fast!=":{exactArity:2},"fast+":{exactArity:2,numeric:!0},"fast-":{exactArity:2,numeric:!0},"fast*":{exactArity:2,numeric:!0},"fast/":{exactArity:2,numeric:!0},"fast//":{exactArity:2,numeric:!0},"fast<":{exactArity:2,numeric:!0},"fast>":{exactArity:2,numeric:!0},"fast<=":{exactArity:2,numeric:!0},"fast>=":{exactArity:2,numeric:!0},inc:{exactArity:1,numeric:!0},dec:{exactArity:1,numeric:!0},min:{minArity:2,numeric:!0},max:{minArity:2,numeric:!0},abs:{exactArity:1,numeric:!0},sqrt:{exactArity:1,numeric:!0},round:{minArity:1,maxArity:2,numeric:!0},floor:{exactArity:1,numeric:!0},ceil:{exactArity:1,numeric:!0},logn:{exactArity:1,numeric:!0},log2:{exactArity:1,numeric:!0},log10:{exactArity:1,numeric:!0},and:{minArity:1},or:{minArity:1},xor:{exactArity:2},"&":{exactArity:2,numeric:!0},"|":{exactArity:2,numeric:!0},"^":{exactArity:2,numeric:!0},"~":{exactArity:1,numeric:!0},"<<":{exactArity:2,numeric:!0},">>":{exactArity:2,numeric:!0},">>>":{exactArity:2,numeric:!0},"odd?":{exactArity:1,numeric:"in only",returns:["bool"]},"even?":{exactArity:1,numeric:"in only",returns:["bool"]},"pos?":{exactArity:1,numeric:"in only",returns:["bool"]},"neg?":{exactArity:1,numeric:"in only",returns:["bool"]},"zero?":{exactArity:1,numeric:"in only",returns:["bool"]},"null?":{exactArity:1,returns:["bool"]},"num?":{exactArity:1,returns:["bool"]},"bool?":{exactArity:1,returns:["bool"]},"str?":{exactArity:1,returns:["bool"]},"vec?":{exactArity:1,returns:["bool"]},"dict?":{exactArity:1,returns:["bool"]},"key?":{exactArity:1,returns:["bool"]},"func?":{exactArity:1,returns:["bool"]},"wild?":{exactArity:1,returns:["bool"]},"ext?":{exactArity:1,returns:["bool"]},rem:{minArity:2,numeric:!0},sin:{exactArity:1,numeric:!0},cos:{exactArity:1,numeric:!0},tan:{exactArity:1,numeric:!0},asin:{exactArity:1,numeric:!0},acos:{exactArity:1,numeric:!0},atan:{exactArity:1,numeric:!0},sinh:{exactArity:1,numeric:!0},cosh:{exactArity:1,numeric:!0},tanh:{exactArity:1,numeric:!0},vec:{returns:["vec"]},dict:{returns:["dict"]},len:{exactArity:1,params:[["str","vec","dict"]],returns:["num"]},"to-num":{exactArity:1,params:[["str","num"]],returns:["num","null"]},"to-key":{exactArity:1,params:[["str","num"]],returns:["key"]},"has?":{exactArity:2,params:["str","str"],returns:["bool"]},idx:{exactArity:2,params:[[],["str","vec"]],returns:["num"]},"set-at":{exactArity:3,params:["vec",[],["vec","dict"]],returns:["vec","dict"]},map:{minArity:2,returns:["vec"]},for:{minArity:2,returns:["vec"]},reduce:{minArity:2,maxArity:3},filter:{minArity:2,params:[[],["vec","dict","str"]],returns:["vec","str","dict"]},remove:{minArity:2,params:[[],["vec","dict","str"]],returns:["vec","str","dict"]},find:{minArity:2,params:[[],["vec","dict","str"]]},count:{minArity:2,params:[[],["vec","dict","str"]],returns:["num"]},repeat:{minArity:2,params:[[],"num"]},"->":{minArity:2},str:{returns:["str"]},rand:{maxArity:2,numeric:!0,returns:["num"]},"rand-int":{maxArity:2,numeric:!0,returns:["num"]},".":{minArity:1},"..":{minArity:2},"...":{minArity:2},into:{exactArity:2,params:[["vec","dict"],["vec","dict"]],returns:["vec","dict"]},push:{minArity:2,maxArity:3,params:[["vec","dict"]],returns:["vec","dict"]},sect:{minArity:1,maxArity:3,params:[["vec","str"],"num","num"],returns:["vec","str"]},reverse:{exactArity:1,params:[["vec","str"]],returns:["vec","str"]},sort:{minArity:1,maxArity:2,params:[["vec","dict","str"]],returns:["vec"]},keys:{exactArity:1,params:["dict"]},vals:{exactArity:1,params:["dict"]},do:{minArity:1},val:{minArity:1},range:{minArity:1,maxArity:3,numeric:"in only",returns:["vec"]},"empty?":{exactArity:1,params:[["str","vec","dict"]],returns:["bool"]},split:{minArity:1,maxArity:2,params:["str","str"],returns:["vec"]},join:{exactArity:2,params:["str",["vec","dict","str"]],returns:["str"]},"starts?":{exactArity:2,params:["str","str"],returns:["bool"]},"ends?":{exactArity:2,params:["str","str"],returns:["bool"]},"lower-case":{exactArity:1,params:["str"],returns:["str"]},"upper-case":{exactArity:1,params:["str"],returns:["str"]},trim:{exactArity:1,params:["str"],returns:["str"]},"trim-start":{exactArity:1,params:["str"],returns:["str"]},"trim-end":{exactArity:1,params:["str"],returns:["str"]},"str*":{exactArity:2,params:["str","num"],returns:["str"]},"char-code":{minArity:1,maxArity:2,params:[["str","num"],"num"],returns:["str","num","null"]},time:{exactArity:0,returns:["num"]},version:{exactArity:0,returns:["num"]},tests:{minArity:0,maxArity:1,params:["bool"],returns:["str"]},symbols:{exactArity:0,returns:["vec"]},eval:{exactArity:1,params:["str"]},reset:{exactArity:0},recur:{}},re={null:"null",str:"string",num:"number",bool:"boolean",key:"keyword",ref:"reference",vec:"vector",dict:"dictionary",func:"function",clo:"closure",wild:"wildcard",ext:"external"},ne=e=>"bool"===e.t?e.v:"null"!==e.t;function ae(e,t,r){const{exactArity:n,maxArity:a,minArity:s}=te[e],o=(n,a)=>[{e:"Arity",m:`${e} needs ${n} argument${1!==a?"s":""}, not ${t}`,errCtx:r}];if(void 0!==n){if(t!==n)return o(`exactly ${n}`,n)}else{if(s&&!a&&t<s)return o(`at least ${s}`,s);if(!s&&a&&t>a)return o(`at most ${a}`,a);if(s&&a&&(t<s||t>a))return o(`between ${s} and ${a}`,a)}}function se(e,t,r,n=!1){const{params:a,numeric:s}=te[e],c=o(t);if(s){const a=t.findIndex((e=>!!o(e)&&(n?!e.find((e=>"num"===e)):"num"!==e[0])));if(-1===a)return;const s=t[a].map((e=>re[e])).join(", ");return[oe(`${e} takes numeric arguments only, not ${s}`,r)]}if(!a)return;const i=a.map(((e,r)=>{if(r>=c||!t[r])return!1;const a=t[r];if(u(e)){if(!o(e)||(n?!o(a)||a.some((t=>m(e,t))):1===o(a)&&m(e,a[0])))return!1;const t=a.map((e=>re[e]));return`argument ${r+1} must be either: ${e.map((e=>re[e])).join(", ")}, not ${t}`}{if(n?!o(a)||m(a,e):1===o(a)&&e===a[0])return!1;const t=a.map((e=>re[e]));return`argument ${r+1} must be ${re[e]}, not ${t}`}})).filter((e=>!!e));return o(i)?i.map((e=>oe(e,r))):void 0}const oe=(e,t)=>({e:"Type",m:e,errCtx:t});function ce(e,t){const r=t.map((e=>re[e])).join(", ");return[oe(`number as operation argument must be string, vector, or dictionary, not ${r}`,e)]}function ie(e,t){const r=t.map((e=>re[e])).join(", ");return[oe(`keyword as operation argument must be dictionary or vector, not ${r}`,e)]}const{has:ue,flat:le,push:ve,slice:de,splice:pe}=r,{slen:me,starts:fe,sub:ye,substr:xe,strIdx:he,subIdx:be}=r,{isNum:ge,len:Ae,toNum:Ce}=r,ke={t:"null",v:void 0},$e={t:"bool",v:!1},we=e=>!!e&&"errCtx"in e,Be=(e,t=0)=>{if(we(e))return"";const r=e[t];return we(r)&&ue(["sym","str"],r.typ)&&r.text||""},Ee=e=>e.map((e=>we(e)?(({typ:e,text:t})=>"str"===e?`"${t}"`:t)(e):`(${Ee(e)})`)).join(" "),Ie=(e,t)=>we(e)?Me(e,t):Pe(e,t);function Pe(e,t,r=!0){if(!Ae(e))return[];const n=e=>Ie(e,t);let a=e.shift(),s=n(a);const{errCtx:o}=s[0];if(we(a)&&"sym"===a.typ){if(a.text in te){const{exactArity:t,minArity:r}=te[a.text],n=t??r;n&&1!==n&&Ae(e)+1===n&&(e.unshift(a),a={typ:"sym",text:"@",errCtx:a.errCtx})}ue(["var","let"],a.text)&&Ae(e)&&Ae(e)%2&&(e.unshift(a),e.push({typ:"sym",text:"%",errCtx:a.errCtx}),a={typ:"sym",text:"#",errCtx:a.errCtx});const{text:o,errCtx:c}=a,i=(e,t=c)=>[{typ:"err",value:e,errCtx:t}];if(ue(["if","if!","when","match"],o)&&!Ae(e))return i("provide a condition");if(ue(["if","if!"],o)){if(1===Ae(e))return i("provide at least one branch");if(Ae(e)>3)return i("provide fewer than two branches");const t=e.map(n),[r,a]=t;let s=t[2];return s||(s=[{typ:"val",value:ke,errCtx:c}]),[...r,..."if!"===o&&[{typ:"val",value:{t:"func",v:"!"},errCtx:c},{typ:"exe",value:1,errCtx:c}]||[],{typ:"if",value:Ae(a)+1,errCtx:c},...a,{typ:"jmp",value:Ae(s),errCtx:c},...s]}if("when"===o){if(1===Ae(e))return i("provide a body");const t=e.map(n),[r,a]=[t[0],de(t,1)],s=le(a);return[...r,{typ:"if",value:Ae(s)+1,errCtx:c},...s,{typ:"jmp",value:1,errCtx:c},{typ:"val",value:ke,errCtx:c}]}if("match"===o){const t=e.map(n),[r,a]=[t[0],de(t,1)],s=Ae(a)%2?a.pop():[];if(!Ae(a))return i("provide at least one case");const o=Ae(s);let u=a.reduce(((e,t)=>e+Ae(t)),0)+(o||2)+Ae(a);const l=r;for(;Ae(a)>1;){const[e,t]=[a.shift(),a.shift()];ve(l,e),l.push({typ:"mat",value:Ae(t)+1,errCtx:c}),ve(l,t),u-=Ae(e)+Ae(t)+2,l.push({typ:"jmp",value:u,errCtx:c})}return Ae(s)?ve(l,s):(l.push({typ:"pop",value:1,errCtx:c}),l.push({typ:"val",value:$e,errCtx:c})),l}if("catch"===o){if(Ae(e)<2)return i("provide at least 2 arguments");const t=n(e.pop());return[...le(e.map(n)),{typ:"cat",value:Ae(t),errCtx:c},...t]}if("and"===o||"or"===o||"while"===o){const t=e.map(n);let r=t.reduce(((e,t)=>e+Ae(t)),0);if(Ae(t)<2)return i("provide at least 2 arguments");const a=[];if("while"===o){a.push({typ:"val",value:ke,errCtx:c}),r+=2;const[e,n]=[t[0],de(t,1)];return ve(a,e),a.push({typ:"if",value:r-Ae(e),errCtx:c}),a.push({typ:"pop",value:Ae(n),errCtx:c}),ve(a,le(n)),a.push({typ:"loo",value:-(r+1),errCtx:c}),a}r+=Ae(t),r+=Ce("and"===o);const s="and"===o?"if":"or";for(let e=0;e<Ae(t);++e)ve(a,t[e]),r-=Ae(t[e]),a.push({typ:s,value:r,errCtx:c}),--r;return"and"===o&&ve(a,[{typ:"val",value:{t:"bool",v:!0},errCtx:c},{typ:"jmp",value:1,errCtx:c}]),a.push({typ:"val",value:$e,errCtx:c}),a}if("var"===o||"let"===o){const r=e.filter(((e,t)=>!(t%2))),a=e.filter(((e,t)=>!!(t%2)));if(!Ae(r))return i("provide at least 1 declaration name and value");if(Ae(r)>Ae(a))return i("provide a value after each declaration name");const s=[];for(let e=0,u=Ae(r);e<u;++e){ve(s,n(a[e]));const u=r[e];if(we(u)){const n=Ie(r[e],t);if(Ae(n)>1||"ref"!==n[0].typ)return i("declaration name must be symbol",n[0].errCtx);s.push({typ:o,value:n[0].value,errCtx:c})}else{const{shape:e,errors:t}=je([u],!0);if(Ae(t))return t;const r="var"===o?"dva":"dle";s.push({typ:r,value:e,errCtx:c})}}return s}if("var!"===o||"let!"===o){if(Ae(e)<2)return i("provide 1 declaration name and 1 function");const t=e.map(n),[r,a,s]=[t[0][0],t[1],de(t,2)];if("ref"!==r.typ)return i("declaration name must be symbol",r.errCtx);const u=[{typ:"ref",value:r.value,errCtx:c}];ve(u,[...le(s),...a]),u.push({typ:"exe",value:Ae(s)+1,errCtx:c});const l="var!"===o?"var":"let";return u.push({typ:l,value:r.value,errCtx:c}),u}if("#"===o||"@"===o||"fn"===o){const r=[];let n=Ee(e);if(n="fn"===o?`(fn ${n})`:`${o}(${n})`,"fn"===o){const n=je(e,!1);if(t=n.shape,ve(r,n.errors),!Ae(e))return i("provide a body");e.unshift({typ:"sym",text:"do",errCtx:c})}"@"===o&&(e=[{typ:"sym",text:"...",errCtx:c},...e,{typ:"sym",text:"args",errCtx:c}]),ve(r,Pe(e,t,"@"!==o));const a=r.filter((e=>"err"!==e.typ)),s=r.filter((e=>"err"===e.typ));if(Ae(s))return s;"fn"===o&&a.forEach((e=>{"npa"===e.typ&&(e.typ="upa")}));const u=[],l=[];for(let e=0;e<Ae(a);++e){const t=a[e],r="val"===t.typ&&e+1<Ae(a)&&"exe"===a[e+1].typ&&("func"===t.value.t&&!te[t.value.v]||"str"===t.value.t);l[e]="ref"===t.typ&&!a.find((e=>("let"===e.typ||"var"===e.typ)&&e.value===t.value))||"npa"===t.typ||r,l[e]&&u.push(t)}return[{typ:"@"===o?"par":"clo",value:{name:n,closureIns:a,captureIns:u,captured:l},errCtx:c}]}if(te[o]&&r){const t=ae(o,Ae(e),c),r=(e,t=c)=>[{typ:"err",value:e,errCtx:t}];ve(s,t?.map((e=>r(e.m)[0]))??[]),t||2===Ae(e)&&te[`fast${o}`]&&(s=n({typ:"sym",text:`fast${o}`,errCtx:c}))}}const c=e.map(n),i=le(c);if("return"===Be([a]))return[...i,{typ:"ret",value:!!Ae(c),errCtx:o}];if("ref"===s[0].typ){const{value:e,errCtx:t}=s[0];s[0]={typ:"val",value:{t:"str",v:e},errCtx:t}}ve(i,s);const u=Ae(s)>1?"exa":"exe";return[...i,{typ:u,value:Ae(c),errCtx:o}]}function Me(e,t){if(we(e)){const{errCtx:r}=e;if("str"===e.typ)return[{typ:"val",value:{t:"str",v:e.text},errCtx:r}];if("num"===e.typ)return[{typ:"val",value:{t:"num",v:Ce(e.text)},errCtx:r}];if("sym"===e.typ){const{text:n}=e,a=t.map((({name:e})=>e));if("true"===n||"false"===n)return[{typ:"val",value:{t:"bool",v:"true"===n},errCtx:r}];if("null"===n)return[{typ:"val",value:ke,errCtx:r}];if("_"===n)return[{typ:"val",value:{t:"wild",v:void 0},errCtx:r}];if(fe(n,":"))return[{typ:"val",value:{t:"key",v:n},errCtx:r}];if(fe(n,"%")&&ge(xe(n,1))){const e=Ce(xe(n,1));return e<0?[{typ:"val",value:ke,errCtx:r}]:[{typ:"upa",value:e,errCtx:r}]}if(ue(a,n)){const e=t.find((({name:e})=>e===n));return 1===Ae(e.position)?[{typ:"npa",value:e.position[0],errCtx:r}]:[{typ:"dpa",value:e.position,errCtx:r}]}return"args"===n?[{typ:"upa",value:-1,errCtx:r}]:"PI"===n||"E"===n?[{typ:"val",value:{t:"num",v:"PI"===n?3.141592653589793:2.718281828459045},errCtx:r}]:te[n]?[{typ:"val",value:{t:"func",v:n},errCtx:r}]:[{typ:"ref",value:n,errCtx:r}]}return[]}return Ae(e)?Pe(e,t):[]}function je(e,t,r=[]){const n=[],a=[];let s=0;for(;Ae(e)>(t?0:1)&&(we(e[0])||"vec"===Be(e[0]));){const t=e.shift();if(we(t)){const{typ:e,errCtx:o}=t;"sym"===e?n.push({name:t.text,position:[...r,s]}):a.push({typ:"err",value:"provide parameter name",errCtx:o})}else{t.shift();const e=je(t,!0,[...r,s]);ve(n,e.shape),ve(a,e.errors)}++s}return{shape:n,errors:a}}function De({name:e,nodes:t}){const{shape:r,errors:n}=je(t,!1),a=[...n,...le(t.map((e=>Me(e,r))))];for(let e=0,t=Ae(a);e<t;e++){const{typ:t,value:r,errCtx:n}=a[e];if("err"===t)return{e:"Parse",m:r,errCtx:n}}return{name:e,ins:a}}function He(e){const t=[];for(let r=0,n=Ae(e);r<n;++r){const n=e[r];switch(n.typ){case"val":t.push({types:[n.value.t],val:n.value});break;case"exa":case"exe":{const e=t.pop(),r=pe(t,Ae(t)-n.value,n.value),a=e=>r.findIndex((({types:t})=>t&&!e.find((e=>ue(t,e))))),s=t=>e.val?e.val.t===t:e.types&&1===Ae(e.types)&&e.types[0]===t;if(e.val&&"func"===e.val.t){if("recur"===e.val.v){pe(t,Ae(t)-n.value,n.value);break}const a=se(e.val.v,r.map((e=>e.types??[])),n.errCtx,!0);if(a)return a;const{returns:s,numeric:o}=te[e.val.v];t.push(o&&"in only"!==o?{types:["num"]}:{types:s})}else if(s("num")){const e=a(["str","dict","vec"]);if(-1!==e)return ce(n.errCtx,r[e].types);t.push({})}else if(s("key")){const e=a(["dict","vec"]);if(-1!==e)return ie(n.errCtx,r[e].types);t.push({})}else s("str")||s("bool")?t.push({}):e.types||e.val||t.push({});break}case"or":t.pop(),t.push({}),r+=n.value;break;case"cat":case"var":case"let":case"dva":case"dle":case"loo":case"jmp":break;case"clo":case"par":{const e=He(n.value.closureIns);if(e)return e}case"ref":case"npa":case"upa":case"dpa":t.push({});break;case"if":{t.pop(),t.push({});const a=He(de(e,r+1,n.value+1));if(a)return a;r+=n.value-1;break}case"mat":t.pop(),t.pop(),r+=n.value,r+=e[r].value,t.push({});break;case"pop":pe(t,Ae(t)-n.value,n.value);break;case"ret":n.value&&t.pop()}}}function Ne(e,t){const{tokens:r,stringError:n}=function(e,t,r=!0,n=!1){const a=[],s=e=>ye("0123456789",e);let[o,c,i,u]=[!1,1,0,[1,0]],[l,v,d]=[!1,!1,!1];for(let p=0,m=me(e);p<m;++p){const f=he(e,p),y=p+1!==m?he(e,p+1):"";if(++i,"\\"===f&&o){a[Ae(a)-1].text+={n:"\n",t:"\t",r:"\r",'"':'"'}[y]||("\\"===y?"\\":`\\${y}`),++i,++p;continue}const x={invokeId:t,line:c,col:i};if('"'===f){(o=!o)&&(u=[c,i],a.push({typ:"str",text:"",errCtx:x})),v=l=!1;continue}const h=ye(" \t\n\r,",f);if(!o&&h){v=l=!1,"\n"===f&&(++c,i=0);continue}if(!o&&";"===f){const t=be(xe(e,++p),"\n"),r=xe(e,p,t>0?t:m-p);p+=me(r),++c,i=0,n&&a.push({typ:"rem",text:r,errCtx:x});continue}const b=ye("()[]{}",f);if(v&&!s(f)){const e="x"===f&&"0"===a[Ae(a)-1].text;d=d||e,v="b"===f&&"0"===a[Ae(a)-1].text||"."===f&&!ye(a[Ae(a)-1].text,".")||d&&(e||ye("ABCDEFabcdef",f)),v||b||h||(l=!0,a[Ae(a)-1].typ="sym")}if(l&&b&&(l=!1),!o&&!l&&!v){if(b){const e=-1===be("[{(",f)?")":"(";a.push({typ:e,text:r?e:f,errCtx:x}),!r||"["!==f&&"{"!==f||a.push({typ:"sym",text:"["===f?"vec":"dict",errCtx:x});continue}v=s(f)||"."===f&&s(y)||"-"===f&&(s(y)||"."===y),d=l=!v;const e=l?"sym":"num";a.push({typ:e,text:"",errCtx:x})}a[Ae(a)-1].text+=f}return{tokens:a,stringError:o?u:void 0}}(e,t),a=function(e,t){const r=Ae(t)?t[0].errCtx.invokeId:"",n=[],a=(e,t)=>n.push({e:"Parse",m:e,errCtx:t});if(e){const[t,s]=e;return a("unmatched double quotation marks",{invokeId:r,line:t,col:s}),n}const s=e=>Ae(t.filter((({typ:t})=>t===e))),[o,c]=[s("("),s(")")];{const[e,n]=function(e,t,r){const n=r>=t,[a,s]=[n?"(":")",n?")":"("],o=n?1:-1;for(let t=Ae(e),r=n?0:t-1,c=0;n?r<t:r>=0;r+=o){const{typ:t,errCtx:{line:n,col:o}}=e[r];if(c+=Ce(t===a)-Ce(t===s),c<0)return[n,o]}return[0,0]}(t,o,c);e+n&&a("unmatched parenthesis",{invokeId:r,line:e,col:n})}let i;for(let e=0,r=!1;e<Ae(t);++e){if(r&&")"===t[e].typ){i=t[e];break}r="("===t[e].typ}return i&&a("empty expression forbidden",i.errCtx),n}(n,r);if(Ae(a))return{errors:a,funcs:{}};const s=[],o=[],c=function(e){const t=[],r=[];return e.forEach((e=>{if(!we(e)&&we(e[0])&&"function"===Be(e)){const r=Be(e,1);r?Ae(e)<3&&t.push({err:"empty function body",errCtx:e[0].errCtx}):t.push({err:"nameless function",errCtx:e[0].errCtx}),t.push({name:r,nodes:de(e,2)})}else r.push(e)})),Ae(r)&&t.push({name:"entry",nodes:r}),t}(function(e){const t=[],r=e=>{let t;"sym"===e[0].typ&&ye("@#",e[0].text)&&(t=e.shift());const n=e.shift();if("("!==n.typ&&")"!==n.typ)return n;const a=t?[t]:[];for(;")"!==e[0].typ;)a.push(r(e));return e.shift(),a};for(;Ae(e);)t.push(r(e));return t}(de(r))),i=[];c.forEach((e=>{"err"in e?o.push({e:"Parse",m:e.err,errCtx:e.errCtx}):i.push({name:e.name,nodes:e.nodes})})),i.map(De).forEach((e=>{"e"in e?o.push(e):s.push(e)})),ve(o,le(s.map((e=>He(e.ins)??[]))));const u={};return s.forEach((e=>u[e.name??""]=e)),{errors:o,funcs:u}}function Se(e,t){return e.dict.has(t)?{kind:"val",value:e.dict.get(t)}:{kind:"err",err:`"${t}" not found.`}}function qe(e,t,r){e.dict.set(t,r)}function Te(e,t,r){switch(t){case"test.function":e.output+=r[0].v+"\n";break;default:return{kind:"err",err:`operation "${t}" does not exist`}}return{kind:"val",value:{t:"null",v:void 0}}}const Oe=[{name:"Hello, world!",code:'"Hello, world!"',out:"Hello, world!"},{name:"Say Hello, world!",code:'(print "Hello, world!")',out:"Hello, world!\nnull"},{name:"1 + 1 = 2",code:"(+ 1 1)",out:"2"},{name:"Negate 1 = -1",code:"(- 1)",out:"-1"},{name:"(1+1)+1+(1+1) = 5",code:"(+ (+ 1 1) 1 (+ 1 1))",out:"5"},{name:"Conditional head",code:"((if true + -) 12 9 1)",out:"22"},{name:"Whens",code:'[(when 123 (print "hi") 234) (when false (print "bye"))]',out:"hi\n[234 null]"},{name:"match and wildcard",code:'(match [1 2]\n             [0 0] (print "hello")\n             [0 2] (print "bye")\n             [1 _] "hey")',out:"hey"},{name:"Cond number head",code:"((if false 1 2) [:a :b :c])",out:":c"},{name:"and & short-circuit",code:'[(and true (if true null 1) (print "hi")) (and 1 2 3)]',out:"[false true]"},{name:"or & short-circuit",code:'[(or true (print "hi") 1) (or false (print-str "-> ") 1)]',out:"-> [true 1]"},{name:"String retrieve",code:'(2 "Hello")',out:"l"},{name:"Vector retrieve",code:"(2 [:a :b :c :d])",out:":c"},{name:"Key as operation",code:'[(:age {:name "Patrick" :age 24}) (:abc [:a :abc :c])]',out:"[24 :abc]"},{name:"Dictionary as op 1",code:'({"name" "Patrick" "age" 24} "age")',out:"24"},{name:"Dictionary as op 2",code:'({"name" "Patrick"} "age" 24)',out:'{"name" "Patrick", "age" 24}'},{name:"Equalities",code:'[(= 1 2 1)\n            (!= 1 2 1)\n            (= "Hello" "hello")\n            (!= "world" "world")\n            (= [0 [1]] [0 [1]])]',out:"[false 1 false false [0 [1]]]"},{name:"Define and retrieve",code:"(var a 1) a",out:"1"},{name:"Define and add",code:"(var a 1) (inc a)",out:"2"},{name:"Define op and call",code:"(var f +) (f 2 2)",out:"4"},{name:"Define vec and call",code:"(var f [1]) (f 1)",out:"1"},{name:"Define num and call",code:"(var f 1) (f [:a :b :c])",out:":b"},{name:"Apply op to var",code:"(var a 10) (var! a + 10)",out:"20"},{name:"Apply op to let",code:"(let a 10) (let! a (if true + -) (+ 2 3) 5)",out:"20"},{name:"Print simple vector",code:"[1 2 3]",out:"[1 2 3]"},{name:"Boolean select",code:"[(true 1 2) (false 1)]",out:"[1 null]"},{name:"Sum vector of numbers",code:"[(reduce + [1 2 3]) (reduce + 3 [1 2 3])]",out:"[6 9]"},{name:"Sum vectors of numbers",code:"(map + [1 2 3] [1 2 3 4])",out:"[2 4 6]"},{name:"For XY list",code:"(for vec [0 1] [0 1])",out:"[[0 0] [1 0] [0 1] [1 1]]"},{name:"Filter by integer",code:'(filter 2 [[1] [:a :b :c] "hello" "hi"])',out:'[[:a :b :c] "hello"]'},{name:"Comments, short decimal",code:';((print "Hello")\n           .456',out:"0.456"},{name:"Dictionary into vector",code:"(into [1 2] {3 4 5 6})",out:"[1 2 [3 4] [5 6]]"},{name:"Vector into dictionary",code:"(into {[0] 1 [2] 3} [[0] 2])",out:"{[0] 2, [2] 3}"},{name:"While loop",code:"(var n 5)\n           (while (< 0 n)\n             (print-str n)\n             (var n (dec n)))",out:"543210"},{name:"Catch error",code:'(catch\n             (:e (catch (let a :a) (+ 1 a) (0 errors)))\n             (print "hi"))',out:"Type"},{name:"Define with no call",code:'(function func (print "Nothing."))'},{name:"Call greet func",code:'(function greeting (print "Hello!")) (greeting)',out:"Hello!\nnull"},{name:"Call const value func",code:"(function const 123) (const)",out:"123"},{name:"Call identity funcs",code:"(function id1 %)\n           (function id2 x x)\n           [(id1 123) (id2 456)]",out:"[123 456]"},{name:"Call greet with name",code:'(function greeting name (print "Hello, " name "!"))\n           (greeting "Patrick")',out:"Hello, Patrick!\nnull"},{name:"Call with too few args",code:"(function func a b c [a b c]) (func 1 2)",out:"[1 2 null]"},{name:"Define func and call",code:"(function func a b (+ a b)) (var f func) (f 2 2)",out:"4"},{name:"Anonymous parameters",code:"(function avg<n? (< (/ (.. + %) (len %)) %1))\n           (avg<n? [0 10 20 30 40] 5)",out:"false"},{name:"Call parameter",code:'(function f x (x "hello")) (f print)',out:"hello\nnull"},{name:"Let and retrieve",code:"(function f (let a 1) a) (f)",out:"1"},{name:"Let num op and call",code:"(function f (let n 0) (n [1])) (f)",out:"1"},{name:"Explicit return",code:"(function f (return 123) (print 456)) (f)",out:"123"},{name:"Closure 1",code:"(let x 10)\n           (let closure #(+ x x))\n           (let x 11)\n           (closure)",out:"20"},{name:"Closure 2",code:"(filter #(or (.. = args) (even? %)) (range 10) 5)",out:"[0 2 4 5 6 8]"},{name:"Closure 3",code:"(function f #(+ x x))\n           (var x 10) (let c20 (f))\n           (var x 20) (let c40 (f))\n           [(c20) (c40)]",out:"[20 40]"},{name:"Func returns closure",code:"(function f x #(x 2 2))\n           (let closure (f +))\n           (closure)",out:"4"},{name:"Dictionary closure",code:"(function f x #{x 2})\n           (let closure (f :a))\n           (closure)",out:"{:a 2}"},{name:"Vector closure",code:"(function f x #[1 x %])\n           (let closure (f 2))\n           (closure 3)",out:"[1 2 3]"},{name:"Closure as head",code:"(#[% %1 %2] 1 2 3)",out:"[1 2 3]"},{name:"Partial closure 1",code:"(@[] 1 2 3)",out:"[1 2 3]"},{name:"Partial closure 2",code:"(@((do +) 2) 2)",out:"4"},{name:"Parameterised closure 1",code:"((fn a b (+ a b)) 2 2)",out:"4"},{name:"Parameterised closure 2",code:"((fn a b (print-str a b) (+ a b)) 2 2)",out:"224"},{name:"Closure with mixed lets",code:"(let a + c 5 d 10)\n           (let closure (fn b (let d 1) (a b c d)))\n           (let a - c 4 d 11)\n           (closure 1)",out:"7"},{name:"Destructure var",code:"(var [x [y]] [1 [2]]) [y x]",out:"[2 1]"},{name:"Destructure string",code:'(let [a b c] "hello") [a b c]',out:'["h" "e" "l"]'},{name:"Destructure function",code:"(function f a [[b c] d] e [e d c b a]) (f 0 [[1 2] 3] 4)",out:"[4 3 2 1 0]"},{name:"Destructuring closure",code:"(let f (fn a [b [c]] d [d c b a])) (f 0 [1 [2]] 3)",out:"[3 2 1 0]"},{name:"Destructuring fn decoy",code:"(let f (fn a [a [a]])) (f 0)",out:"[0 [0]]"},{name:"Threading",code:"(-> 1 inc @(+ 10))",out:"12"},{name:"String instead of number",code:'(function sum (.. + args))\n           (print (sum 2 2))\n           (sum 2 "hi")',out:"4",err:["Type"]},{name:"Reference non-existing",code:"x",err:["Reference"]},{name:"Expired let retrieve",code:"(function f (let a 1) a) (f) a",err:["Reference"]},{name:"Call non-existing",code:"(x)",err:["External"]},{name:"Call budget",code:"(function f (f)) (f)",err:["Budget"]},{name:"Loop budget",code:"(var n 10000)\n           (while (< 0 n)\n             (var n (dec n)))",err:["Budget"]},{name:"Range budget",code:"(range 10000)",err:["Budget"]},{name:"Head exe arity check",code:"(((fn +)) 1)",err:["Arity"]},{name:"Fibonacci 13",code:"(function fib n\n             (if (< n 2) n\n               (+ (fib (dec n))\n                  (fib (- n 2)))))\n           (fib 13)",out:"233"},{name:"dedupe (recur)",code:"(function dedupe list -out\n             (let out (or -out []))\n             (let next (if (out (0 list)) [] [(0 list)]))\n             (if (empty? list) out\n                 (recur (sect list) (into out next))))\n           (dedupe [1 1 2 3 3 3])",out:"[1 2 3]"},{name:"frequencies",code:'(function frequencies list\n             (reduce #(push % %1 (inc (or (% %1) 0))) {} list))\n           (frequencies "12121212")',out:'{"1" 4, "2" 4}'},{name:"set get",code:"[($globals.time_offset 5.5) $globals.time_offset]",out:"[5.5 5.5]"},{name:"exe",code:"(test.function 123)",out:"123\nnull"},{name:"Empty parens",code:"()",err:["Parse"]},{name:"Imbalanced parens 1",code:'(print ("hello!")',err:["Parse"]},{name:"Imbalanced parens 2",code:'print "hello!")',err:["Parse"]},{name:"Imbalanced quotes",code:'(print "Hello)',err:["Parse"]},{name:"Function as op",code:"(function)",err:["Parse"]},{name:"Function without name",code:"(function (+))",err:["Parse"]},{name:"Function without body",code:"(function func)",err:["Parse"]},{name:"Variable not symbol",code:"(var 1 2)",err:["Parse"]},{name:"Parser type error 1",code:"(function f (+ 1 :a))",err:["Type"]},{name:"Parser type error 2",code:"(function f (+ 1 (into {} {})))",err:["Type"]},{name:"Parser type error 3",code:"(function f (if true (into 2 {}) (+ 2 2)))",err:["Type"]},{name:"Parser arity error 1",code:"(abs)",err:["Parse"]}],Fe=({v:e})=>e,_e=({v:e})=>e,Re=({v:e})=>e,Le=({v:e})=>e,Ve=(e,t)=>o(e)===o(t)&&!e.some(((e,r)=>!We(e,t[r]))),We=(e,t)=>{if("wild"===e.t||"wild"===t.t)return!0;if(e.t!==t.t)return!1;switch(e.t){case"null":return!0;case"bool":case"num":return e.v===t.v;case"vec":return Ve(e.v,Re(t));case"dict":{const r=Le(t);return o(e.v.keys)===o(r.keys)&&Ve(e.v.keys,r.keys)}case"str":case"ref":case"key":case"func":return _e(e)===_e(t);case"clo":return e.v.name===t.v.name;case"ext":return e.v===t.v}return 0},Ke=e=>e.reduce(((e,t)=>e+ze(t)),""),ze=e=>{const t=e=>"str"===e.t?`"${e.v}"`:ze(e);if("clo"===e.t)return e.v.name??"";if("vec"===e.t)return`[${e.v.map(t).join(" ")}]`;if("dict"===e.t){const{keys:r,vals:n}=e.v,[a,s]=[r.map(t),n.map(t)];return`{${a.map(((e,t)=>`${e} ${s[t]}`)).join(", ")}}`}return"null"===e.t?"null":"wild"===e.t?"_":`${e.v}`},Ue=e=>"vec"===e.t?a(e.v):"str"===e.t?[...e.v].map((e=>({t:"str",v:e}))):"dict"===e.t?e.v.keys.map(((t,r)=>({t:"vec",v:[t,e.v.vals[r]]}))):[],Xe=e=>{o(e)%2==1&&e.pop();const t=e.filter(((e,t)=>t%2==0)),r=e.filter(((e,t)=>t%2==1)),n=[],a=[];return t.forEach(((e,t)=>{const s=n.findIndex((t=>We(t,e)));-1===s?(n.push(e),a.push(r[t])):a[s]=r[t]})),{t:"dict",v:{keys:n,vals:a}}},Ye=({keys:e,vals:t},r)=>{const n=e.findIndex((e=>We(e,r)));return-1===n?{t:"null",v:void 0}:t[n]},Ge=({keys:e,vals:t},r,n)=>{const[s,o]=[a(e),a(t)],c=e.findIndex((e=>We(e,r)));return-1!==c?o[c]=n:(s.push(r),o.push(n)),{keys:s,vals:o}};function Je(e,t,r){if(!o(e)||"vec"!==r.t&&"dict"!==r.t||"vec"===r.t&&("num"!==e[0].t||e[0].v<0||e[0].v>o(r.v)))return r;if("vec"===r.t){const n=a(r.v),s=Fe(e[0]);return 1===o(e)?(n[s]=t,{t:"vec",v:n}):(n[s]=Je(a(e,1),t,n[s]),{t:"vec",v:n})}return 1===o(e)?{t:"dict",v:Ge(r.v,e[0],t)}:{t:"dict",v:Ge(r.v,e[0],Je(a(e,1),t,Ye(r.v,e[0])))}}const{abs:Qe,sign:Ze,sqrt:et,floor:tt,ceil:rt,round:nt,max:at,min:st,logn:ot,log2:ct,log10:it}=r,{cos:ut,sin:lt,tan:vt,acos:dt,asin:pt,atan:mt,sinh:ft,cosh:yt,tanh:xt}=r,{concat:ht,has:bt,flat:gt,push:At,reverse:Ct,slice:kt,splice:$t,sortBy:wt}=r,{ends:Bt,slen:Et,starts:It,sub:Pt,subIdx:Mt,substr:jt,upperCase:Dt,lowerCase:Ht}=r,{trim:Nt,trimStart:St,trimEnd:qt,charCode:Tt,codeChar:Ot,strIdx:Ft}=r,{getTimeMs:_t,randInt:Rt,randNum:Lt}=r,{isNum:Vt,len:Wt,objKeys:Kt,range:zt,toNum:Ut}=r,Xt={};let Yt,Gt=[],Jt=[],Qt={};const Zt=e=>Gt.push({t:"bool",v:e}),er=e=>Gt.push({t:"num",v:e}),tr=(e="")=>Gt.push({t:"str",v:e}),rr=(e=[])=>Gt.push({t:"vec",v:e}),nr=e=>Gt.push({t:"dict",v:e}),ar=()=>Gt.push({t:"null",v:void 0}),sr=e=>Gt.push({t:"func",v:e});function or(e,t,r,n,c){const i=e=>[oe(e,n)];if(c){const r=ae(e,Wt(t),n);if(r)return r}{const r=se(e,t.map((e=>[e.t])),n);if(r)return r}switch(e){case"str":return void Gt.push({t:"str",v:Ke(t)});case"print":case"print-str":return r.print(Ke(t),"print"===e),void ar();case"vec":return void rr(t);case"dict":return void Gt.push(Xe(t));case"len":return void er("str"===t[0].t?Et(t[0].v):"vec"===t[0].t?Wt(t[0].v):Wt(Le(t[0]).keys));case"to-num":return void(Vt(t[0].v)?er(Ut(t[0].v)):ar());case"to-key":return void Gt.push({t:"key",v:`:${ze(t[0])}`});case"!":return void Zt(!ne(t[0]));case"=":case"!=":for(let r=1,n=Wt(t);r<n;++r)if(We(t[r-1],t[r])!==("="===e))return void Zt(!1);return void Gt.push(t[0]);case"-":return void er(1===Wt(t)?-Fe(t[0]):t.map(Fe).reduce(((e,t)=>e-t)));case"**":return void er(Fe(t[0])**(1===Wt(t)?2:Fe(t[1])));case"+":return void er(t.map(Fe).reduce(((e,t)=>e+t)));case"*":return void er(t.map(Fe).reduce(((e,t)=>e*t)));case"/":return void er(t.map(Fe).reduce(((e,t)=>e/t)));case"//":return void er(t.map(Fe).reduce(((e,t)=>tt(e/t))));case"fast=":case"fast!=":return We(t[0],t[1])!==("fast="===e)?void Zt(!1):void Gt.push(t[0]);case"fast-":return void er(t[0].v-t[1].v);case"fast+":return void er(t[0].v+t[1].v);case"fast*":return void er(t[0].v*t[1].v);case"fast/":return void er(t[0].v/t[1].v);case"fast//":return void er(tt(t[0].v/t[1].v));case"fast<":return void Zt(t[0].v<t[1].v);case"fast>":return void Zt(t[0].v>t[1].v);case"fast<=":return void Zt(t[0].v<=t[1].v);case"fast>=":return void Zt(t[0].v>=t[1].v);case"rem":return void er(t.map(Fe).reduce(((e,t)=>e%t)));case"min":return void er(t.map(Fe).reduce(((e,t)=>st(e,t))));case"max":return void er(t.map(Fe).reduce(((e,t)=>at(e,t))));case"<":case">":case"<=":case">=":for(let r=1,n=Wt(t);r<n;++r){const[n,a]=[t[r-1].v,t[r].v];if("<"===e&&n>=a||">"===e&&n<=a||"<="===e&&n>a||">="===e&&n<a)return void Zt(!1)}return void Zt(!0);case"inc":return void er(t[0].v+1);case"dec":return void er(t[0].v-1);case"abs":return void er(Qe(t[0].v));case"round":if(2===Wt(t)){const e=10**t[0].v;er(nt(t[1].v*e)/e)}else er(nt(t[0].v));return;case"sin":case"cos":case"tan":case"sqrt":case"floor":case"ceil":case"logn":case"log2":case"log10":return void er((0,{sin:lt,cos:ut,tan:vt,sqrt:et,floor:tt,ceil:rt,logn:ot,log2:ct,log10:it}[e])(Fe(t[0])));case"asin":case"acos":case"atan":case"sinh":case"cosh":case"tanh":return void er((0,{asin:pt,acos:dt,atan:mt,sinh:ft,cosh:yt,tanh:xt}[e])(Fe(t[0])));case"and":return void Zt(t.every(ne));case"or":return void Zt(t.some(ne));case"xor":return void(ne(t[0])!==ne(t[1])?Gt.push(ne(t[0])?t[0]:t[1]):Zt(!1));case"&":case"|":case"^":case"<<":case">>":case">>>":const[c,u]=[Fe(t[0]),Fe(t[1])];return void er("&"===e?c&u:"|"===e?c|u:"^"===e?c^u:"<<"===e?c<<u:">>"===e?c>>u:c>>>u);case"~":return void er(~Fe(t[0]));case"odd?":case"even?":return void Zt(Fe(t[0])%2==("odd?"===e?1:0));case"pos?":case"neg?":case"zero?":{const r=Fe(t[0]);return void Zt("pos?"===e?r>0:"neg?"===e?r<0:!r)}case"null?":case"num?":case"bool?":case"str?":case"dict?":case"vec?":case"key?":case"func?":case"wild?":case"ext?":{const{t:r}=t[0];return void Zt("func?"===e&&("func"===r||"clo"===r)||jt(e,0,Et(e)-1)===r)}case"has?":return void Zt(Pt(_e(t[0]),_e(t[1])));case"idx":{let e=-1;if("str"===t[0].t){if("str"!==t[1].t)return i("strings can only contain strings");e=Mt(t[1].v,t[0].v)}else"vec"===t[0].t&&(e=t[0].v.findIndex((e=>We(e,t[1]))));return void(-1===e?ar():er(e))}case"set-at":{const[e,r,n]=t;return void Gt.push(Je(Re(e),r,n))}case"map":case"for":case"reduce":case"filter":case"remove":case"find":case"count":{const a=ir(r,t.shift(),n);if("map"===e||"for"===e){const e=t.findIndex((({t:e})=>"vec"!==e&&"str"!==e&&"dict"!==e));if(-1!==e)return i(`argument ${e+2} must be either: string, vector, dictionary, not ${re[t[e].t]}`)}if("for"===e){const e=t.map(Ue),s=e.map(Wt),o=s.map(((e,t)=>kt(s,0,t+1).reduce(((e,t)=>e*t))));o.unshift(1);const c=o.pop();if(c>r.loopBudget)return[{e:"Budget",m:"would exceed loop budget",errCtx:n}];const i=[];for(let t=0;t<c;++t){const r=o.map(((e,r)=>tt(t/e%s[r]))),n=a(e.map(((e,t)=>e[r[t]])));if(n)return n;i.push(Gt.pop())}return void rr(i)}if("map"===e){const e=t.map(Ue),r=st(...e.map(Wt)),n=[];for(let t=0;t<r;++t){const r=a(e.map((e=>e[t])));if(r)return r;n.push(Gt.pop())}return void rr(n)}if("reduce"!==e){const r=t.shift(),n=Ue(r),s="remove"===e,o="find"===e,c="count"===e,i=[];let u=0;for(let e=0,r=Wt(n);e<r;++e){const r=a([n[e],...t]);if(r)return r;const l=ne(Gt.pop());if(c)u+=l?1:0;else if(o){if(l)return void Gt.push(n[e])}else l!==s&&i.push(n[e])}switch(e){case"count":return void er(u);case"find":return void ar()}return void("str"===r.t?tr(i.map((e=>ze(e))).join("")):"dict"===r.t?Gt.push(Xe(gt(i.map((e=>e.v))))):rr(i))}const s=t.pop();if(!bt(["vec","dict","str"],s.t))return i(`must reduce either: string, vector, dictionary, not ${re[s.t]}`);const o=Ue(s);if(!Wt(o))return void(Wt(t)?Gt.push(t[0]):rr());if(Wt(o)<2&&!Wt(t))return void At(Gt,o);let c=(Wt(t)?t:o).shift();for(let e=0,t=Wt(o);e<t;++e){const t=a([c,o[e]]);if(t)return t;c=Gt.pop()}return void Gt.push(c)}case"repeat":{const e=t.shift(),a=[],s=Fe(t[0]);if(s>r.rangeBudget)return[{e:"Budget",m:"would exceed range budget",errCtx:n}];if(r.rangeBudget-=s,"func"===e.t||"clo"===e.t){const t=ir(r,e,n);for(let e=0;e<s;++e){const r=t([{t:"num",v:e}]);if(r)return r;a.push(Gt.pop())}}else for(let t=0;t<s;++t)a.push(e);return void rr(a)}case"->":Gt.push(t.shift());for(let e=0,a=Wt(t);e<a;++e){const a=ir(r,t[e],n)([Gt.pop()]);if(a)return a}return;case"rand-int":case"rand":{const r=Wt(t),[n,a]=[r<2?0:Fe(t[0]),0===r?1+Ut("rand-int"===e):Fe(1===r?t[0]:t[1])];er("rand-int"===e?Rt(n,a):Lt(n,a))}return;case"do":case"val":return void Gt.push("do"===e?t.pop():t.shift());case".":case"..":case"...":{const a=ir(r,t.shift(),n);if("."===e)return a(t);let s=t;if(".."===e)s=gt(t.map((e=>"vec"===e.t?e.v:[e])));else{const e=s.pop();At(s,gt(["vec"===e.t?e.v:[e]]))}return a(s)}case"into":if("vec"===t[0].t)rr(ht(t[0].v,Ue(t[1])));else if("vec"===t[1].t)Gt.push(Xe(ht(gt(Ue(t[0]).map(Re)),t[1].v)));else{const{keys:e,vals:r}=Le(t[0]),n=Le(t[1]);nr({keys:ht(e,n.keys),vals:ht(r,n.vals)})}return;case"push":if("vec"===t[0].t){const e=t[0].v;if(Wt(t)<3)rr(ht(e,[t[1]]));else{const r=Fe(t[2]);rr(ht(ht(kt(e,0,r),[t[1]]),kt(e,r)))}}else Wt(t)<3?Gt.push((({keys:e,vals:t},r)=>{const[n,o]=[a(e),a(t)],c=e.findIndex((e=>We(e,r)));return-1!==c&&(s(n,c,1),s(o,c,1)),{t:"dict",v:{keys:n,vals:o}}})(Le(t[0]),t[1])):nr(Ge(Le(t[0]),t[1],t[2]));return;case"sect":{const e=t[0],r="vec"===e.t?Wt(e.v):Et(_e(e));let n=0,a=r;switch(Wt(t)){case 1:n=1;break;case 2:{const e=Fe(t[1]);e<0?a+=e:n+=e;break}case 3:{const e=Fe(t[1]),s=Fe(t[2]);n=e<0?r+e+(s<0?s:0):n+e,a=(s<0?a:n)+s;break}}return n=at(n,0),a=st(a,r),n>a?void("vec"===e.t?rr:tr)():void("vec"===e.t?rr(kt(e.v,n,a)):tr(jt(_e(t[0]),n,a-n)))}case"reverse":return void("str"===t[0].t?tr(Ke(Ct(Ue(t[0])))):rr(Ct(Ue(t[0]))));case"sort":{const e=Ue(t[0]);if(!Wt(e))return void rr();const a=[];if(1===Wt(t))At(a,e.map((e=>[e,e])));else{const s=ir(r,t.pop(),n);for(let t=0,r=Wt(e);t<r;++t){const r=s([e[t]]);if(r)return r;a.push([e[t],Gt.pop()])}}const s=a[0][1].t;return a.some((([e,{t}])=>t!==s||!bt(["num","str"],t)))?i("can only sort by all number or all string"):(wt(a,"num"===s?([e,t],[r,n])=>Fe(t)>Fe(n)?1:-1:([e,t],[r,n])=>_e(t)>_e(n)?1:-1),void rr(a.map((([e])=>e))))}case"range":{const[e,a,s]=t.map(Fe),o=s&&s<0&&e<a,[c,i]=Wt(t)>1?o?[a-1,e-1]:[e,a]:[0,e],u=Ze((i-c)*(s||1))*(s||1),l=rt(Qe((i-c)/u));if(!l)return void rr([]);if(l>r.rangeBudget)return[{e:"Budget",m:"would exceed range budget",errCtx:n}];r.rangeBudget-=l;const v=zt(l).map((e=>e*u+c));return void rr(v.map((e=>({t:"num",v:e}))))}case"empty?":return void Zt(!Wt(Ue(t[0])));case"keys":case"vals":return void rr(Le(t[0])["keys"===e?"keys":"vals"]);case"split":return void rr(_e(t[Wt(t)-1]).split(Wt(t)-1?_e(t[0]):" ").map((e=>({t:"str",v:e}))));case"join":return void tr(Ue(t[1]).map(ze).join(_e(t[0])));case"starts?":case"ends?":return void Zt(("starts?"===e?It:Bt)(_e(t[1]),_e(t[0])));case"upper-case":case"lower-case":case"trim":case"trim-start":case"trim-end":return void tr(("upper-case"===e?Dt:"lower-case"===e?Ht:"trim"===e?Nt:"trim-start"===e?St:qt)(_e(t[0])));case"str*":{const e=_e(t[0]);return void tr(zt(at(rt(Fe(t[1])),0)).map((t=>e)).join(""))}case"char-code":if("str"===t[0].t){const e=Wt(t)>1?Fe(t[1]):0,r=_e(t[0]);Et(r)<=e||e<0?ar():er(Tt(Ft(r,e)))}else tr(Ot(Fe(t[0])));return;case"time":return void er(_t());case"version":return void er(20220122);case"tests":return void tr(function(e,t=!0){const r=[];for(let t=0;t<o(Oe);++t){const{name:n,code:a,err:s,out:o}=Oe[t],c={dict:new Map,output:""},i={funcs:{},vars:{}},u=N(),l=e({get:e=>Se(c,e),set:(e,t)=>qe(c,e,t),print:(e,t)=>{c.output+=e+(t?"\n":"")},exe:(e,t)=>Te(c,e,t),functions:[],env:i,loopBudget:1e4,rangeBudget:1e3,callBudget:1e3,recurBudget:1e4},a,a,!0),v="errors"===l.kind?l.errors:[],d=(s||[]).join()===v.map((({e})=>e)).join(),p=!o||$(c.output)===o,m=N()-u,[f,y,x,h,b]=[E(`${t+1}`,3),E(n,24),E(`${X(m)}ms`,6),p||o+"\t!=\t"+$(c.output),d||v.map((({e,m:t,errCtx:{line:r,col:n}})=>`${e} ${r}:${n}: ${t}`))];r.push({okErr:d,okOut:p,elapsedMs:m,display:`${f} ${y} ${x} ${h} ${b}`})}const n=r.reduce(((e,{elapsedMs:t})=>e+t),0),a=o(r.filter((({okOut:e,okErr:t})=>e&&t)));return h(r.filter((e=>!t||!e.okOut||!e.okErr)).map((e=>e.display)),[`---- ${a}/${o(r)} tests passed in ${X(n)}ms.`])}(pr,!(Wt(t)&&ne(t[0]))).join("\n"));case"symbols":return void rr(function(e,t=!0){let r=t?["function","let","var","if","if!","when","while","match","catch"]:[];At(r,["args","PI","E"]),r=ht(r,Kt(te)),r=ht(r,Kt(e.env.funcs)),r=ht(r,Kt(e.env.vars));const n=["entry"];return r=r.filter((e=>!bt(n,e))),wt(r,((e,t)=>e>t?1:-1))}(r,!1).map((e=>({t:"str",v:e}))));case"eval":{delete r.env.funcs.entry;const e=Wt(Gt),a=`${n.invokeId} eval`,s=dr(r,_e(t[0]),a);return s?[{e:"Eval",m:"error within evaluated code",errCtx:n},...s]:void(e===Wt(Gt)&&ar())}case"recur":return void(Yt=t);case"reset":return r.env.vars={},r.env.funcs={},Jt=[],void ar()}return[{e:"Unexpected",m:"operation doesn't exist",errCtx:n}]}const cr=(e,t)=>[{e:"Arity",m:`${re[e]} as op requires one sole argument`,errCtx:t}];function ir(e,t,r,n=!0){if("str"===t.t||"func"===t.t){const a=t.v;return te[a]?te[a].external?e=>{const t=Xt[a](e);if("err"===t.kind)return[{e:"External",m:t.err,errCtx:r}];Gt.push(t.value)}:t=>or(a,t,e,r,n):a in e.env.funcs?t=>vr(e,e.env.funcs[a],t):a in e.env.vars?ir(e,e.env.vars[a],r):a in Qt?ir(e,Qt[a],r):It(a,"$")?n=>{if(!Wt(n))return cr(t.t,r);const s=e.set(jt(a,1),n[0]);return Gt.push(n[0]),s?[{e:"External",m:s,errCtx:r}]:void 0}:t=>{const n=e.exe(a,t);if("val"!==n.kind)return[{e:"External",m:n.err,errCtx:r}];Gt.push(n.value)}}if("clo"===t.t)return r=>vr(e,t.v,r);if("key"===t.t)return e=>{if(!Wt(e))return cr(t.t,r);if("dict"===e[0].t)Gt.push(Ye(Le(e[0]),t));else{if("vec"!==e[0].t)return ie(r,[e[0].t]);{const r=Re(e[0]).find((e=>We(e,t)));Gt.push(r??{t:"null",v:void 0})}}};if("num"===t.t){const e=tt(t.v);return n=>{if(!Wt(n))return cr(t.t,r);const a=n[0];if("str"!==a.t&&"vec"!==a.t&&"dict"!==a.t)return ce(r,[a.t]);const s=Ue(a),o=Wt(s);e>=0&&e>=o||e<0&&-e>o?ar():e<0?Gt.push(s[o+e]):Gt.push(s[e])}}if("vec"===t.t){const{v:e}=t;return n=>{if(!Wt(n))return cr(t.t,r);const a=e.find((e=>We(e,n[0])));a?Gt.push(a):ar()}}if("dict"===t.t){const e=t.v;return t=>{if(1===Wt(t))Gt.push(Ye(e,t[0]));else{if(2!==Wt(t))return[{e:"Arity",m:"provide 1 or 2 arguments for dictionary",errCtx:r}];nr(Ge(e,t[0],t[1]))}}}if("bool"===t.t){const e=t.v;return t=>{if(!Wt(t)||Wt(t)>2)return[{e:"Arity",m:"provide 1 or 2 arguments for boolean",errCtx:r}];Gt.push(e?t[0]:Wt(t)>1?t[1]:{t:"null",v:void 0})}}return e=>[{e:"Operation",m:`${ze(t)} is an invalid operation`,errCtx:r}]}function ur(e){const t=(e,t,r)=>Ge(e,{t:"key",v:t},r);return e.map((({e,m:r,errCtx:n})=>{let a=t({keys:[],vals:[]},":e",{t:"str",v:e});return a=t(a,":m",{t:"str",v:r}),a=t(a,":line",{t:"num",v:n.line}),a=t(a,":col",{t:"num",v:n.col}),{t:"dict",v:a}}))}function lr(e,t){let r=e;for(let e=0,n=Wt(t)-1;e<n;++e){const a=r[t[e]];if("vec"!==a.t)return"str"===a.t&&e+1===n&&t[e+1]<Et(a.v)?{t:"str",v:Ft(a.v,t[e+1])}:{t:"null",v:void 0};r=a.v}const n=t[Wt(t)-1];return n>=Wt(r)?{t:"null",v:void 0}:r[n]}function vr(e,t,r,n=!1){--e.callBudget,n||(Jt.push({}),Qt=Jt[Wt(Jt)-1]);const a=Wt(Gt);for(let n=0,s=Wt(t.ins);n<s;++n){const o=t.ins[n],{errCtx:c}=t.ins[n],i=e.loopBudget<1;if(i||e.callBudget<1)return[{e:"Budget",m:(i?"looped":"called")+" too many times",errCtx:c}];switch(o.typ){case"val":Gt.push(o.value);break;case"var":e.env.vars[o.value]=Gt[Wt(Gt)-1];break;case"let":Qt[o.value]=Gt[Wt(Gt)-1];break;case"dle":case"dva":{const t=Gt.pop();let r;o.value.forEach((({name:n,position:a})=>{r="dva"===o.typ?e.env.vars[n]=lr([t],a):Qt[n]=lr([t],a)})),Gt.push(r);break}case"npa":case"upa":{const e=o.value;-1===e?rr(r):Wt(r)<=e?ar():Gt.push(r[e]);break}case"dpa":Gt.push(lr(r,o.value));break;case"ref":{const t=o.value;if(te[t])sr(t);else if(It(t,"$")){const r=e.get(jt(t,1));if("err"===r.kind)return[{e:"External",m:r.err,errCtx:c}];Gt.push(r.value)}else if(t in e.env.vars)Gt.push(e.env.vars[t]);else if(t in Qt)Gt.push(Qt[t]);else{if(!(t in e.env.funcs))return[{e:"Reference",m:`"${t}" did not exist`,errCtx:c}];sr(t)}break}case"exa":case"exe":{const a=ir(e,Gt.pop(),c,"exa"===o.typ),s=o.value,i=a($t(Gt,Wt(Gt)-s,s));if(i){const e=kt(t.ins,n).findIndex((e=>"cat"===e.typ));if(-1!==e){n+=e,Qt.errors={t:"vec",v:ur(i)};break}return i}if(Yt){if(Jt[Wt(Jt)-1]={},n=-1,o.value,r=Yt,Yt=void 0,--e.recurBudget,!e.recurBudget)return[{e:"Budget",m:"recurred too many times",errCtx:c}];break}break}case"or":ne(Gt[Wt(Gt)-1])?n+=o.value:Gt.pop();break;case"mat":{const e=Gt[Wt(Gt)-2];We(e,Gt.pop())?Gt.pop():n+=o.value;break}case"if":ne(Gt.pop())||(n+=o.value);break;case"jmp":case"cat":n+=o.value;break;case"loo":n+=o.value,--e.loopBudget;break;case"pop":$t(Gt,Wt(Gt)-o.value,o.value);break;case"ret":o.value?$t(Gt,a,Wt(Gt)-a-1):ar(),n=s;break;case"clo":case"par":{const{name:t,captured:n,captureIns:a}=o.value;let{closureIns:s}=o.value;const i=[];if(Wt(a)){s=s.map(((t,r)=>{const a="val"===t.typ&&"str"===t.value.t&&(Qt[t.value.v]??e.env.vars[t.value.v]);return n[r]=!a&&n[r],a?{typ:"val",value:a}:t}));const t=vr(e,{ins:a},r,!0);if(t)return t;const o=Wt(a),u=$t(Gt,Wt(Gt)-o,o),l=e=>({typ:"val",value:e,errCtx:c});for(let e=0,t=0;e<Wt(n);++e)i.push(n[e]?l(u[t++]):s[e])}else At(i,s);Gt.push({t:"clo",v:{name:t,ins:i}});break}}}n||(Jt.pop(),Qt=Jt[Wt(Jt)-1],$t(Gt,a,Wt(Gt)-(a+1)))}function dr(e,t,r){const n=Ne(t,r);return Wt(n.errors)?n.errors:(e.env.funcs={...e.env.funcs,...n.funcs},"entry"in e.env.funcs?vr(e,e.env.funcs.entry,[]):void 0)}function pr(e,t,r,n=!1){const a=function(e,t){const{callBudget:r,loopBudget:n,recurBudget:a,rangeBudget:s}=e;e.functions.forEach((({name:e,definition:t,handler:r})=>{if(te[e]&&!Xt[e])throw"Redefining internal operations is disallowed.";te[e]={...t,external:!0},Xt[e]=r}));const o=t();e.functions.forEach((({name:e})=>{delete te[e],delete Xt[e]})),[e.callBudget,e.recurBudget]=[r,a],[e.loopBudget,e.rangeBudget]=[n,s],delete e.env.funcs.entry;const c=Gt.pop();return[Gt,Jt]=[[],[]],o?{kind:"errors",errors:o}:c?{kind:"val",value:c}:{kind:"empty"}}(e,(()=>dr(e,t,r)));return n&&"val"===a.kind&&e.print(ze(a.value),!0),a}const mr=new Map,fr=/[\[\]\(\) ,]/;function yr(e,t,r){r=r?`-${r}`:`${N()}`,mr.set(r,t);const n=pr(e,t,r,!0);if("errors"!==n.kind)return[];let a=[];const s=e=>a.push({type:"message",text:e}),o=e=>a.push({type:"error",text:e});return n.errors.forEach((({e,m:t,errCtx:{line:r,col:n,invokeId:a}})=>{const i=mr.get(a);if(!i)return void s(`${e} Error: ${a} line ${r} col ${n}: ${t}\n`);const u=i.split("\n")[r-1],v=l(u,n-1).split(fr)[0],d=w(l(u,0,n-1)),p=f(a,"-")?`${l(a,1)} `:"";if(s(`${p}${E(`${r}`,4)} ${d}`),v){const e=l(u,n-1+c(v));o(v),s(`${e}\n`)}else{const e=l(u,n);o(u[n-1]),s(`${e}\n`)}s(`${e} Error: ${t}.\n`)})),a}window.insitux=t.invoker})();
//# sourceMappingURL=insitux.lib.min.js.map