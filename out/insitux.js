(()=>{"use strict";var e={d:(t,r)=>{for(var n in r)e.o(r,n)&&!e.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:r[n]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.d(t,{invoker:()=>Vt});var r={};e.r(r),e.d(r,{abs:()=>N,ceil:()=>W,concat:()=>h,cos:()=>O,ends:()=>y,flat:()=>x,floor:()=>L,getTimeMs:()=>H,has:()=>f,isArray:()=>u,isNum:()=>i,len:()=>a,log10:()=>U,log2:()=>z,logn:()=>V,lowerCase:()=>C,max:()=>q,min:()=>S,objKeys:()=>M,padEnd:()=>I,pi:()=>K,push:()=>b,randInt:()=>j,randNum:()=>E,range:()=>P,reverse:()=>A,round:()=>R,sign:()=>_,sin:()=>D,slen:()=>c,slice:()=>s,sortBy:()=>g,splice:()=>o,sqrt:()=>F,starts:()=>v,strIdx:()=>p,sub:()=>m,subIdx:()=>d,substr:()=>l,tan:()=>T,toNum:()=>n,trim:()=>w,trimEnd:()=>B,trimStart:()=>$,upperCase:()=>k});const n=e=>Number(e),s=(e,t,r)=>e.slice(t,r),o=(e,t,r)=>e.splice(t,r),a=e=>e.length,c=e=>e.length,i=e=>!Number.isNaN(Number(e)),u=e=>Array.isArray(e),l=(e,t,r)=>e.substring(t,t+(r??e.length)),p=(e,t)=>e[t],m=(e,t)=>e.includes(t),d=(e,t)=>e.indexOf(t),f=(e,t)=>e.includes(t),v=(e,t)=>e.startsWith(t),y=(e,t)=>e.endsWith(t),x=e=>e.flat(),h=(e,t)=>e.concat(t),b=(e,t)=>e.push(...t),g=(e,t)=>e.sort(t),A=e=>e.reverse(),C=e=>e.toLowerCase(),k=e=>e.toUpperCase(),w=e=>e.trim(),$=e=>e.trimStart(),B=e=>e.trimEnd(),I=(e,t)=>e.padEnd(t),E=(e,t)=>e+Math.random()*(t-e),j=(e,t)=>Math.floor(E(e,t)),P=e=>[...Array(e).keys()],M=e=>Object.keys(e),H=()=>(new Date).getTime(),N=Math.abs,S=Math.min,q=Math.max,D=Math.sin,O=Math.cos,T=Math.tan,F=Math.sqrt,R=Math.round,L=Math.floor,W=Math.ceil,_=Math.sign,K=Math.PI,V=Math.log,z=Math.log2,U=Math.log10,G={print:{returns:["null"]},"print-str":{returns:["null"]},"!":{exactArity:1,returns:["bool"]},"=":{minArity:2},"!=":{minArity:2},"+":{minArity:2,numeric:!0},"-":{minArity:1,numeric:!0},"*":{minArity:2,numeric:!0},"/":{minArity:2,numeric:!0},"//":{minArity:2,numeric:!0},"**":{minArity:1,numeric:!0},"<":{minArity:2,numeric:!0},">":{minArity:2,numeric:!0},"<=":{minArity:2,numeric:!0},">=":{minArity:2,numeric:!0},inc:{exactArity:1,numeric:!0},dec:{exactArity:1,numeric:!0},min:{minArity:2,numeric:!0},max:{minArity:2,numeric:!0},abs:{exactArity:1,numeric:!0},pi:{exactArity:0,numeric:!0},sqrt:{exactArity:1,numeric:!0},round:{exactArity:1,numeric:!0},floor:{exactArity:1,numeric:!0},ceil:{exactArity:1,numeric:!0},logn:{exactArity:1,numeric:!0},log2:{exactArity:1,numeric:!0},log10:{exactArity:1,numeric:!0},and:{minArity:1},or:{minArity:1},"odd?":{exactArity:1,numeric:"in only",returns:["bool"]},"even?":{exactArity:1,numeric:"in only",returns:["bool"]},"pos?":{exactArity:1,numeric:"in only",returns:["bool"]},"neg?":{exactArity:1,numeric:"in only",returns:["bool"]},"zero?":{exactArity:1,numeric:"in only",returns:["bool"]},"null?":{exactArity:1,returns:["bool"]},"num?":{exactArity:1,returns:["bool"]},"bool?":{exactArity:1,returns:["bool"]},"str?":{exactArity:1,returns:["bool"]},"vec?":{exactArity:1,returns:["bool"]},"dict?":{exactArity:1,returns:["bool"]},"key?":{exactArity:1,returns:["bool"]},"func?":{exactArity:1,returns:["bool"]},rem:{minArity:2,numeric:!0},sin:{exactArity:1,numeric:!0},cos:{exactArity:1,numeric:!0},tan:{exactArity:1,numeric:!0},vec:{returns:["vec"]},dict:{returns:["dict"]},len:{exactArity:1,types:[["str","vec","dict"]],returns:["num"]},"to-num":{exactArity:1,types:[["str","num"]],returns:["num","null"]},"to-key":{exactArity:1,types:[["str","num"]],returns:["key"]},"has?":{exactArity:2,types:["str","str"],returns:["bool"]},idx:{minArity:2,maxArity:3,types:[["str","vec"]],returns:["num"]},map:{minArity:2,returns:["vec"]},for:{minArity:2,returns:["vec"]},reduce:{minArity:2,maxArity:3},filter:{minArity:2,returns:["vec"]},remove:{minArity:2,returns:["vec"]},find:{minArity:2},count:{minArity:2,returns:["num"]},str:{returns:["str"]},rand:{maxArity:2,numeric:!0,returns:["num"]},"rand-int":{maxArity:2,numeric:!0,returns:["num"]},while:{},"..":{minArity:2},"...":{minArity:2},into:{exactArity:2,types:[["vec","dict"],["vec","dict"]],returns:["vec","dict"]},push:{minArity:2,maxArity:3,types:[["vec","dict"]],returns:["vec","dict"]},sect:{minArity:1,maxArity:3,types:[["vec","str"],"num","num"],returns:["vec","str"]},reverse:{exactArity:1,types:[["vec","str"]],returns:["vec","str"]},sort:{minArity:1,maxArity:2,types:["vec"],returns:["vec"]},keys:{exactArity:1,types:["dict"]},vals:{exactArity:1,types:["dict"]},do:{minArity:1},val:{minArity:1},range:{minArity:1,maxArity:3,numeric:!0},"empty?":{exactArity:1,types:[["str","vec","dict"]],returns:["bool"]},split:{minArity:1,maxArity:2,types:["str","str"],returns:["vec"]},join:{minArity:1,maxArity:2,types:["vec","str"],returns:["str"]},"starts-with?":{exactArity:2,types:["str","str"],returns:["bool"]},"ends-with?":{exactArity:2,types:["str","str"],returns:["bool"]},"lower-case":{exactArity:1,types:["str"],returns:["str"]},"upper-case":{exactArity:1,types:["str"],returns:["str"]},trim:{exactArity:1,types:["str"],returns:["str"]},"trim-start":{exactArity:1,types:["str"],returns:["str"]},"trim-end":{exactArity:1,types:["str"],returns:["str"]},"str*":{exactArity:2,types:["str","num"],returns:["str"]},time:{exactArity:0,returns:["num"]},version:{exactArity:0,returns:["num"]},tests:{minArity:0,maxArity:1,types:["bool"],returns:["str"]},symbols:{exactArity:0,returns:["vec"]},eval:{exactArity:1,types:["str"]},reset:{exactArity:0}},J={null:"null",str:"string",num:"number",bool:"boolean",key:"keyword",ref:"reference",vec:"vector",dict:"dictionary",func:"function",clo:"closure"},Q=(e,t)=>({e:"Type",m:e,errCtx:t});function X(e,t){const r=t.map((e=>J[e])).join(", ");return[Q(`number as operation argument must be string, vector, or dictionary, not ${r}`,e)]}function Y(e,t){const r=t.map((e=>J[e])).join(", ");return[Q(`keyword as operation argument must be dictionary or vector, not ${r}`,e)]}const{concat:Z,has:ee,flat:te,push:re,slice:ne,splice:se}=r,{slen:oe,starts:ae,sub:ce,substr:ie,strIdx:ue}=r,{isNum:le,len:pe,toNum:me,isArray:de}=r,fe={t:"null",v:void 0};function ve(e,t){const r=[];for(;;){const n=he(e,t);if(!pe(n))break;re(r,n)}return r}function ye(e,t,r){const{exactArity:n,maxArity:s,minArity:o}=G[e],a=(n,s)=>[{e:"Arity",m:`${e} needs ${n} argument${1!==s?"s":""}, not ${t}`,errCtx:r}];if(void 0!==n){if(t!==n)return a(`exactly ${n}`,n)}else{if(o&&!s&&t<o)return a(`at least ${o}`,o);if(!o&&s&&t>s)return a(`at most ${s}`,s);if(o&&s&&(t<o||t>s))return a(`between ${o} and ${s}`,s)}}function xe(e,t,r,n=!1){const{types:s,numeric:o}=G[e],a=pe(t);if(o){const s=t.findIndex((e=>pe(e)&&(n?!e.find((e=>"num"===e)):"num"!==e[0])));if(-1===s)return;const o=t[s].map((e=>J[e])).join(", ");return[Q(`${e} takes numeric arguments only, not ${o}`,r)]}if(!s)return;const c=s.map(((e,r)=>{if(r>=a||!t[r])return!1;const s=t[r];if(de(e)){if(n?!pe(s)||s.some((t=>ee(e,t))):1===pe(s)&&ee(e,s[0]))return!1;const t=s.map((e=>J[e]));return`argument ${r+1} must be either: ${e.map((e=>J[e])).join(", ")}, not ${t}`}{if(n?!pe(s)||ee(s,e):1===pe(s)&&e===s[0])return!1;const t=s.map((e=>J[e]));return`argument ${r+1} must be ${J[e]}, not ${t}`}})).filter((e=>!!e));return pe(c)?c.map((e=>Q(e,r))):void 0}function he(e,t,r=!0){if(!pe(e))return[];const{typ:n,text:s,errCtx:o}=e.shift();if("sym"===n&&ce("#@",s)&&pe(e)&&"("===e[0].typ){const r=e.map((e=>e.text)),n=he(e,t,"@"!==s),a=n.find((e=>"err"===e.typ));return a?[a]:[{typ:"#"===s?"clo":"par",value:[ne(r,0,pe(r)-pe(e)).join(" "),n],errCtx:o}]}switch(n){case"str":return[{typ:"val",value:{t:"str",v:s},errCtx:o}];case"num":return[{typ:"val",value:{t:"num",v:me(s)},errCtx:o}];case"sym":if("true"===s||"false"===s)return[{typ:"val",value:{t:"bool",v:"true"===s},errCtx:o}];if("null"===s)return[{typ:"val",value:fe,errCtx:o}];if(ae(s,":"))return[{typ:"val",value:{t:"key",v:s},errCtx:o}];if(ae(s,"%")&&le(ie(s,1))){const e=me(ie(s,1));return e<0?[{typ:"val",value:fe,errCtx:o}]:[{typ:"upa",value:e,errCtx:o}]}return ee(t,s)?[{typ:"npa",value:t.indexOf(s),errCtx:o}]:"args"===s?[{typ:"upa",value:-1,errCtx:o}]:G[s]?[{typ:"val",value:{t:"func",v:s},errCtx:o}]:[{typ:"ref",value:s,errCtx:o}];case"(":return function(e,t,r=!0){const n=e.shift();if(!n)return[];const{typ:s,text:o,errCtx:a}=n;let c=o;const i=e=>[{typ:"err",value:e,errCtx:a}];if("catch"===c){if("("!==e[0].typ)return i("argument 1 must be expression");const r=he(e,t),n=ve(e,t);return pe(r)&&pe(n)?[...r,{typ:"cat",value:pe(n),errCtx:a},...n]:i("must provide at least 2 arguments")}if("var"===c||"let"===c){const r=[];for(;;){const n=he(e,t);if(pe(r)&&!pe(n))return r;const s=he(e,t);if(!(pe(r)||pe(n)&&pe(s)))return i("must provide at least one declaration name and value");if(!pe(s))return i("must provide a value after each declaration name");const o=n[0];if("ref"!==o.typ)return i("declaration name must be symbol");re(r,s),r.push({typ:c,value:o.value,errCtx:a})}}else{if("if"===c||"when"===c){const r=he(e,t);if(!pe(r))return i("must provide condition");const n=r;if("if"===c){const r=he(e,t);if(!pe(r))return i("must provide a branch");n.push({typ:"if",value:pe(r)+1,errCtx:a}),re(n,r);const s=he(e,t);if(pe(s)){if(n.push({typ:"jmp",value:pe(s),errCtx:a}),re(n,s),pe(he(e,t)))return i("too many branches")}else n.push({typ:"jmp",value:1,errCtx:a}),n.push({typ:"val",value:fe,errCtx:a})}else{const r=ve(e,t);n.push({typ:"if",value:pe(r)+1,errCtx:a}),re(n,r),n.push({typ:"jmp",value:1,errCtx:a}),n.push({typ:"val",value:fe,errCtx:a})}return n}if("and"===c||"or"===c||"while"===c||"recur"===c){const r=[];let n=0;for(;;){const s=he(e,t);if(!pe(s))break;r.push(s),n+=pe(s)}if("recur"===c)return[...te(r),{typ:"rec",value:pe(r),errCtx:a}];if(pe(r)<2)return i("requires at least two arguments");const s=[];if("while"===c){s.push({typ:"val",value:fe,errCtx:a}),n+=2;const e=r.shift();return re(s,e),s.push({typ:"if",value:n-pe(e),errCtx:a}),s.push({typ:"pop",value:pe(r),errCtx:a}),r.forEach((e=>re(s,e))),s.push({typ:"loo",value:-(n+1),errCtx:a}),s}n+=pe(r),n+=me("and"===c);const o="and"===c?"if":"or";for(let e=0;e<pe(r);++e)re(s,r[e]),n-=pe(r[e]),s.push({typ:o,value:n,errCtx:a}),--n;return"and"===c?re(s,[{typ:"val",value:{t:"bool",v:!0},errCtx:a},{typ:"jmp",value:1,errCtx:a},{typ:"val",value:{t:"bool",v:!1},errCtx:a}]):s.push({typ:"val",value:{t:"bool",v:!1},errCtx:a}),s}}const u=[];let l=0;if("("===s||ee(t,o)||ce("%#@",ue(o,0))){e.unshift(n);const r=he(e,t);re(u,r)}const p=[];for(;pe(e);){const r=he(e,t);if(!pe(r))break;++l,re(p,r)}if("return"===c)return[...p,{typ:"ret",value:!!pe(p),errCtx:a}];if(G[c]&&r){const e=ye(c,l,a);re(u,e?.map((e=>i(e.m)[0]))??[])}if(pe(u))u.push({typ:"exe",value:l,errCtx:a});else{const e="num"===s?{t:"num",v:me(c)}:ae(c,":")?{t:"key",v:c}:G[c]?{t:"func",v:c}:"true"===c||"false"===c?{t:"bool",v:"true"===c}:{t:"str",v:c};u.push({typ:"val",value:e,errCtx:a}),u.push({typ:"exe",value:l,errCtx:a})}return[...p,...u]}(e,t,r);case")":case"rem":return[];default:return 0}}function be(e){const t=[];for(let r=0,n=pe(e);r<n;++r){const n=e[r];switch(n.typ){case"val":t.push({types:[n.value.t],val:n.value});break;case"exe":{const e=t.pop(),r=se(t,pe(t)-n.value,n.value),s=e=>r.findIndex((({types:t})=>t&&!e.find((e=>ee(t,e))))),o=t=>e.val?e.val.t===t:e.types&&1===pe(e.types)&&e.types[0]===t;if(e.val&&"func"===e.val.t){const s=xe(e.val.v,r.map((e=>e.types??[])),n.errCtx,!0);if(s)return s;const{returns:o,numeric:a}=G[e.val.v];t.push(a&&"in only"!==a?{types:["num"]}:{types:o})}else if(o("num")){const e=s(["str","dict","vec"]);if(-1!==e)return X(n.errCtx,r[e].types)}else if(o("key")){const e=s(["dict","vec"]);if(-1!==e)return Y(n.errCtx,r[e].types)}break}case"cat":case"or":case"var":case"let":case"loo":break;case"clo":case"par":{const e=be(n.value[1]);if(e)return e}case"ref":case"npa":case"upa":t.push({});break;case"if":t.pop(),t.push({});case"jmp":r+=n.value-("if"===n.typ?1:0);break;case"pop":case"rec":se(t,pe(t)-n.value,n.value);break;case"ret":n.value&&t.pop()}}return[]}function ge(e,t){const{tokens:r,stringError:n}=function(e,t,r=!0,n=!1){const s=[];let o=!1,a=!1,c=[0,0],i=!1,u=!1,l=!1,p=1,m=0;for(let d=0,f=oe(e);d<f;++d){const v=ue(e,d),y=d+1!==f?ue(e,d+1):"";if(++m,l){"\n"===v?(l=!1,++p,m=0):n&&(s[pe(s)-1].text+=v);continue}if(a){a=!1,o&&(s[pe(s)-1].text+={n:"\n",t:"\t",'"':'"'}[v]||`\\${v}`);continue}if("\\"===v){a=!0;continue}if('"'===v){(o=!o)&&(c=[p,m],s.push({typ:"str",text:"",errCtx:{invocationId:t,line:p,col:m}})),u=i=!1;continue}const x=ce(" \t\n\r,",v);if(!o&&x){u=i=!1,"\n"===v&&(++p,m=0);continue}if(!o&&";"===v){l=!0,n&&s.push({typ:"rem",text:"",errCtx:{invocationId:t,line:p,col:m}});continue}const h={invocationId:t,line:p,col:m},b=e=>ce("0123456789",e),g=ce("()[]{}",v);if(u&&!b(v)&&(u="."===v&&!ce(s[pe(s)-1].text,"."),u||g||x||(i=!0,s[pe(s)-1].typ="sym")),i&&g&&(i=!1),!o&&!i&&!u){if(g){const e={"[":"(","{":"(","(":"(",")":")","}":")","]":")"}[v];s.push({typ:e,text:r?e:v,errCtx:h}),r&&("["===v?s.push({typ:"sym",text:"vec",errCtx:h}):"{"===v&&s.push({typ:"sym",text:"dict",errCtx:h}));continue}u=b(v)||"."===v&&b(y)||"-"===v&&(b(y)||"."===y),i=!u;let e=i?"sym":"num";s.push({typ:e,text:"",errCtx:h})}s[pe(s)-1].text+=v}return{tokens:s,stringError:o?c:void 0}}(e,t),s=function(e,t){const r=pe(t)?t[0].errCtx.invocationId:"",n=[],s=(e,t)=>n.push({e:"Parse",m:e,errCtx:t}),o=e=>pe(t.filter((({typ:t})=>t===e))),[a,c]=[o("("),o(")")];{const[e,n]=function(e,t,r){const n=r>=t,[s,o]=[n?"(":")",n?")":"("],a=n?1:-1;for(let t=pe(e),r=n?0:t-1,c=0;n?r<t:r>=0;r+=a){const{typ:t,errCtx:{line:n,col:a}}=e[r];if(c+=me(t===s)-me(t===o),c<0)return[n,a]}return[0,0]}(t,a,c);e+n&&s("unmatched parenthesis",{invocationId:r,line:e,col:n})}if(e){const[t,n]=e;s("unmatched double quotation marks",{invocationId:r,line:t,col:n})}let i;for(let e=0,r=!1;e<pe(t);++e){if(r&&")"===t[e].typ){i=t[e];break}r="("===t[e].typ}return i&&s("empty expression forbidden",i.errCtx),n}(n,r);if(pe(s))return{errors:s,funcs:{}};const o=function(e){const t=[[]];let r=0;return e.forEach((e=>{t[pe(t)-1].push(e),r+=me("("===e.typ)-me(")"===e.typ),0===r&&t.push([])})),t}(r),a=function(e){const t=e=>pe(e)>1&&"sym"===e[1].typ&&"function"===e[1].text,r=e.filter((e=>t(e))),n=te(e.filter((e=>!t(e)))),s=r.map((e=>({name:e[2].text,tokens:ne(e,3),errCtx:e[2].errCtx})));return pe(n)?Z(s,[{name:"entry",tokens:n,errCtx:n[0].errCtx}]):s}(o),c=a.map((e=>function({name:e,tokens:t},r){const n=(e,t=r)=>["err",{e:"Parse",m:e,errCtx:t}],[s,o]=function(e,t){const r=[],n=[];for(let t=0,o=!1;t<pe(e);++t)o||(o="sym"!==(s=e[t]).typ||ce("%#@",s.text)),(o?n:r).push(e[t]);var s;return[r,n]}(t);if("("===e)return n("nameless function");if(!pe(s)&&!pe(o))return n("empty function body");if(pe(o)&&")"===o[0].typ){if(!pe(s))return n("empty function body");o.unshift(s.pop())}pe(s)&&!pe(o)&&o.push(s.pop());const a=[];for(;pe(o);)re(a,he(o,s.map((e=>e.text))));const c=a.find((e=>"err"===e.typ));return c?n(c.value,c.errCtx):["func",{name:e,ins:a}]}(e,{invocationId:t,line:e.errCtx.line,col:e.errCtx.col}))),i=[],u=[];c.forEach((e=>{"err"===e[0]?u.push(e[1]):i.push(e[1])})),re(u,te(i.map((e=>be(e.ins)))));const l={};return i.forEach((e=>l[e.name]=e)),{errors:u,funcs:l}}async function Ae(e,t){return e.dict.has(t)?{value:e.dict.get(t),err:void 0}:{value:{t:"null",v:void 0},err:`"${t} not found.`}}async function Ce(e,t,r){e.dict.set(t,r)}async function ke(e,t,r){const n={t:"null",v:void 0};switch(t){case"print-str":e.output+=r[0].v;break;case"print":case"test.function":e.output+=r[0].v+"\n";break;default:return{value:n,err:`operation ${t} does not exist`}}return{value:n,err:void 0}}const we=[{name:"Hello, world!",code:'"Hello, world!"',out:"Hello, world!"},{name:"Say Hello, world!",code:'(print "Hello, world!")',out:"Hello, world!\nnull"},{name:"1 + 1 = 2",code:"(+ 1 1)",out:"2"},{name:"Negate 1 = -1",code:"(- 1)",out:"-1"},{name:"(1+1)+1+(1+1) = 5",code:"(+ (+ 1 1) 1 (+ 1 1))",out:"5"},{name:"Conditional head",code:"((if true + -) 12 9 1)",out:"22"},{name:"Whens",code:'[(when 123 (print "hi") 234) (when false (print "bye"))]',out:"hi\n[234 null]"},{name:"Cond number head",code:"((if false 1 2) [:a :b :c])",out:":c"},{name:"and & short-circuit",code:"[(and true (if true null 1) true) (and 1 2 3)]",out:"[false true]"},{name:"or & short-circuit",code:'[(or true (print "hello") 1) (or false (print-str "-> ") 1)]',out:"-> [true 1]"},{name:"String retrieve",code:'(2 "Hello")',out:"l"},{name:"Vector retrieve",code:"(2 [:a :b :c :d])",out:":c"},{name:"Key as operation",code:'[(:age {:name "Patrick" :age 24}) (:abc [:a :abc :c])]',out:"[24 :abc]"},{name:"Dictionary as op 1",code:'({"name" "Patrick" "age" 24} "age")',out:"24"},{name:"Dictionary as op 2",code:'({"name" "Patrick"} "age" 24)',out:'{"name" "Patrick", "age" 24}'},{name:"Equalities",code:'[(= 1 2 1)\n            (!= 1 2 1)\n            (= "Hello" "hello")\n            (!= "world" "world")\n            (= [0 [1]] [0 [1]])]',out:"[false 1 false false [0 [1]]]"},{name:"Define and retrieve",code:"(var a 1) a",out:"1"},{name:"Define and add",code:"(var a 1) (inc a)",out:"2"},{name:"Define op and call",code:"(var f +) (f 2 2)",out:"4"},{name:"Define vec and call",code:"(var f [1]) (f 1)",out:"1"},{name:"Define num and call",code:"(var f 1) (f [:a :b :c])",out:":b"},{name:"Print simple vector",code:"[1 2 3]",out:"[1 2 3]"},{name:"Boolean select",code:"[(true 1 2) (false 1)]",out:"[1 null]"},{name:"Sum vector of numbers",code:"[(reduce + [1 2 3]) (reduce + [1 2 3] 3)]",out:"[6 9]"},{name:"Sum vectors of numbers",code:"(map + [1 2 3] [1 2 3 4])",out:"[2 4 6]"},{name:"Filter by integer",code:'(filter 2 [[1] [:a :b :c] "hello" "hi"])',out:'[[:a :b :c] "hello"]'},{name:"Comments, short decimal",code:';((print "Hello")\n           .456',out:"0.456"},{name:"Dictionary into vector",code:"(into [1 2] {3 4 5 6})",out:"[1 2 [3 4] [5 6]]"},{name:"Vector into dictionary",code:"(into {[0] 1 [2] 3} [[0] 2])",out:"{[0] 2, [2] 3}"},{name:"While loop",code:"(var n 5)\n           (while (< 0 n)\n             (print-str n)\n             (var n (dec n)))",out:"543210"},{name:"Catch error",code:'(catch\n             (:e (catch (do (let a :a) (+ 1 a)) (0 errors)))\n             (print "hi"))',out:"Type"},{name:"Define with no call",code:'(function func (print "Nothing."))'},{name:"Call greet func",code:'(function greeting (print "Hello!")) (greeting)',out:"Hello!\nnull"},{name:"Call const value func",code:"(function const 123) (const)",out:"123"},{name:"Call identity funcs",code:"(function id1 %)\n           (function id2 x x)\n           [(id1 123) (id2 456)]",out:"[123 456]"},{name:"Call greet with name",code:'(function greeting name (print "Hello, " name "!"))\n           (greeting "Patrick")',out:"Hello, Patrick!\nnull"},{name:"Call with too few args",code:"(function func a b c [a b c]) (func 1 2)",out:"[1 2 null]"},{name:"Define func and call",code:"(function func a b (+ a b)) (var f func) (f 2 2)",out:"4"},{name:"Anonymous parameters",code:"(function avg<n? (< (/ (.. + %) (len %)) %1))\n           (avg<n? [0 10 20 30 40] 5)",out:"false"},{name:"Call parameter",code:'(function f x (x "hello")) (f print)',out:"hello\nnull"},{name:"Let and retrieve",code:"(function f (let a 1) a) (f)",out:"1"},{name:"Let num op and call",code:"(function f (let n 0) (n [1])) (f)",out:"1"},{name:"Explicit return",code:"(function f (return 123) (print 456)) (f)",out:"123"},{name:"Closure 1",code:"(let x 10)\n           (let closure #(+ x x))\n           (let x 11)\n           (closure)",out:"20"},{name:"Closure 2",code:"(filter #(or (.. = args) (even? %)) (range 10) 5)",out:"[0 2 4 5 6 8]"},{name:"Closure 3",code:"(function f #(+ x x))\n           (var x 10) (let c20 (f))\n           (var x 20) (let c40 (f))\n           [(c20) (c40)]",out:"[20 40]"},{name:"Func returns closure",code:"(function f x #(x 2 2))\n           (let closure (f +))\n           (closure)",out:"4"},{name:"Dictionary closure",code:"(function f x #{x 2})\n           (let closure (f :a))\n           (closure)",out:"{:a 2}"},{name:"Vector closure",code:"(function f x #[1 x %])\n           (let closure (f 2))\n           (closure 3)",out:"[1 2 3]"},{name:"Closure as head",code:"(#[% %1 %2] 1 2 3)",out:"[1 2 3]"},{name:"Partial closure 1",code:"(@[] 1 2 3)",out:"[1 2 3]"},{name:"String instead of number",code:'(function sum (.. + args))\n           (print (sum 2 2))\n           (sum 2 "hi")',out:"4",err:["Type"]},{name:"Reference non-existing",code:"x",err:["Reference"]},{name:"Expired let retrieve",code:"(function f (let a 1) a) (f) a",err:["Reference"]},{name:"Call non-existing",code:"(x)",err:["External"]},{name:"Call budget",code:"(function f (f)) (f)",err:["Budget"]},{name:"Loop budget",code:"(var n 10000)\n           (while (< 0 n)\n             (var n (dec n)))",err:["Budget"]},{name:"Range budget",code:"(range 10000)",err:["Budget"]},{name:"Fibonacci 13",code:"(function fib n\n             (if (< n 2) n\n               (+ (fib (dec n))\n                  (fib (- n 2)))))\n           (fib 13)",out:"233"},{name:"dedupe (recur)",code:"(function dedupe list -out\n             (let out (or -out []))\n             (let next (if (out (0 list)) [] [(0 list)]))\n             (if (empty? list) out\n                 (recur (sect list) (into out next))))\n           (dedupe [1 1 2 3 3 3])",out:"[1 2 3]"},{name:"set get",code:"[($globals.time_offset 5.5) $globals.time_offset]",out:"[5.5 5.5]"},{name:"exe",code:"(test.function 123)",out:"123\nnull"},{name:"Empty parens",code:"()",err:["Parse"]},{name:"Imbalanced parens 1",code:'(print ("hello!")',err:["Parse"]},{name:"Imbalanced parens 2",code:'print "hello!")',err:["Parse"]},{name:"Imbalanced quotes 1",code:'(print "Hello)',err:["Parse","Parse"]},{name:"Imbalanced quotes 2",code:'print "Hello")',err:["Parse"]},{name:"Function as op",code:"(function)",err:["Parse"]},{name:"Function without name",code:"(function (+))",err:["Parse"]},{name:"Function without body",code:"(function func)",err:["Parse"]},{name:"Parser type error 1",code:"(function f (+ 1 :a))",err:["Type"]},{name:"Parser type error 2",code:"(function f (+ 1 (into {} {})))",err:["Type"]}];async function $e(e,t=!0){const r=[];for(let t=0;t<a(we);++t){const{name:n,code:s,err:o,out:a}=we[t],c={dict:new Map,output:""},i={funcs:{},vars:{}},u=H(),l=await e({get:e=>Ae(c,e),set:(e,t)=>Ce(c,e,t),exe:(e,t)=>ke(c,e,t),env:i,loopBudget:1e4,rangeBudget:1e3,callBudget:1e3,recurBudget:1e4},s,"testing",!0),p=(o||[]).join()===l.map((({e})=>e)).join(),m=!a||w(c.output)===a,d=H()-u,[f,v,y,x,h]=[I(`${t+1}`,3),I(n,24),I(`${d}ms`,6),m||a+"\t=/=\t"+w(c.output),p||l.map((({e,m:t,errCtx:{line:r,col:n}})=>`${e} ${r}:${n}: ${t}`))];r.push({okErr:p,okOut:m,elapsedMs:d,display:`${f} ${v} ${y} ${x} ${h}`})}const n=r.reduce(((e,{elapsedMs:t})=>e+t),0),s=a(r.filter((({okOut:e,okErr:t})=>e&&t)));return h(r.filter((e=>!t||!e.okOut||!e.okErr)).map((e=>e.display)),[`---- ${s}/${a(r)} tests passed in ${n}ms.`])}const{abs:Be,cos:Ie,sin:Ee,tan:je,pi:Pe,sign:Me,sqrt:He,floor:Ne,ceil:Se,round:qe,max:De,min:Oe}=r,{logn:Te,log2:Fe,log10:Re}=r,{concat:Le,has:We,flat:_e,push:Ke,reverse:Ve,slice:ze,splice:Ue,sortBy:Ge}=r,{ends:Je,slen:Qe,starts:Xe,sub:Ye,subIdx:Ze,substr:et,upperCase:tt,lowerCase:rt}=r,{trim:nt,trimStart:st,trimEnd:ot}=r,{getTimeMs:at,randInt:ct,randNum:it}=r,{isNum:ut,len:lt,objKeys:pt,range:mt,toNum:dt}=r,ft=({v:e,t})=>{const r=e=>"str"===e.t?`"${e.v}"`:ft(e);switch(t){case"bool":case"num":return`${e}`;case"str":case"key":case"ref":case"func":return e;case"clo":return`#${e.name}`;case"vec":return`[${e.map(r).join(" ")}]`;case"dict":{const{keys:t,vals:n}=e,[s,o]=[t.map(r),n.map(r)];return`{${s.map(((e,t)=>`${e} ${o[t]}`)).join(", ")}}`}case"null":return"null"}return 0};let vt=[],yt=[];const xt=e=>vt.push({t:"bool",v:e}),ht=e=>vt.push({t:"num",v:e}),bt=(e="")=>vt.push({t:"str",v:e}),gt=(e=[])=>vt.push({t:"vec",v:e}),At=e=>vt.push({t:"dict",v:e}),Ct=()=>vt.push({t:"null",v:void 0}),kt=e=>vt.push({t:"func",v:e}),wt=({v:e})=>e,$t=({v:e})=>e,Bt=({v:e})=>e,It=({v:e})=>e,Et=({v:e})=>e,jt=({t:e,v:t})=>"bool"===e?t:"null"!==e,Pt=({t:e,v:t})=>"vec"===e?ze(t):"str"===e?[...t].map((e=>({t:"str",v:e}))):"dict"===e?t.keys.map(((e,r)=>({t:"vec",v:[e,t.vals[r]]}))):[],Mt=e=>e.reduce(((e,t)=>e+ft(t)),""),Ht=e=>{lt(e)%2==1&&e.pop();const t=e.filter(((e,t)=>t%2==0)),r=e.filter(((e,t)=>t%2==1)),n=[],s=[];return t.forEach(((e,t)=>{const o=n.findIndex((t=>St(t,e)));-1===o?(n.push(e),s.push(r[t])):s[o]=r[t]})),{t:"dict",v:{keys:n,vals:s}}},Nt=(e,t)=>lt(e)===lt(t)&&!e.some(((e,r)=>!St(e,t[r]))),St=(e,t)=>{const{t:r}=e;switch(r){case"null":return!0;case"bool":return e.v===t.v;case"num":return wt(e)===wt(t);case"vec":return Nt(Bt(e),Bt(t));case"dict":return((e,t)=>{const[r,n]=[It(e),It(t)];return lt(r.keys)===lt(n.keys)&&Nt(r.keys,n.keys)})(e,t);case"str":case"ref":case"key":case"func":return $t(e)===$t(t);case"clo":return Et(e).name===Et(t).name}return 0},qt=({keys:e,vals:t},r)=>{const n=e.findIndex((e=>St(e,r)));return-1===n?{t:"null",v:void 0}:t[n]},Dt=({keys:e,vals:t},r,n)=>{const[s,o]=[ze(e),ze(t)],a=e.findIndex((e=>St(e,r)));return-1!==a?o[a]=n:(s.push(r),o.push(n)),{keys:s,vals:o}};async function Ot(e,t,r,n,s){const o=e=>[Q(e,n)];if(s){const r=ye(e,lt(t),n);if(r)return r}{const r=xe(e,t.map((e=>[e.t])),n);if(r)return r}switch(e){case"str":return void vt.push({t:"str",v:Mt(t)});case"print":case"print-str":return r.exe(e,[{t:"str",v:Mt(t)}]),void Ct();case"vec":return void gt(t);case"dict":return void vt.push(Ht(t));case"len":return void ht("str"===t[0].t?Qe($t(t[0])):"vec"===t[0].t?lt(Bt(t[0])):lt(It(t[0]).keys));case"to-num":return void(ut(t[0].v)?ht(dt(t[0].v)):Ct());case"to-key":return a=`:${ft(t[0])}`,void vt.push({t:"key",v:a});case"!":return void xt(!jt(t[0]));case"=":case"!=":for(let r=1,n=lt(t);r<n;++r)if(St(t[r-1],t[r])!==("="===e))return void xt(!1);return void vt.push(t[0]);case"-":return void ht(1===lt(t)?-wt(t[0]):t.map(wt).reduce(((e,t)=>e-t)));case"**":return void ht(wt(t[0])**(1===lt(t)?2:wt(t[1])));case"+":return void ht(t.map(wt).reduce(((e,t)=>e+t)));case"*":return void ht(t.map(wt).reduce(((e,t)=>e*t)));case"/":return void ht(t.map(wt).reduce(((e,t)=>e/t)));case"//":return void ht(t.map(wt).reduce(((e,t)=>Ne(e/t))));case"rem":return void ht(t.map(wt).reduce(((e,t)=>e%t)));case"min":return void ht(t.map(wt).reduce(((e,t)=>Oe(e,t))));case"max":return void ht(t.map(wt).reduce(((e,t)=>De(e,t))));case"<":case">":case"<=":case">=":for(let r=1,n=lt(t);r<n;++r){const[n,s]=[t[r-1].v,t[r].v];if("<"===e&&n>=s||">"===e&&n<=s||"<="===e&&n>s||">="===e&&n<s)return void xt(!1)}return void xt(!0);case"inc":return void ht(t[0].v+1);case"dec":return void ht(t[0].v-1);case"abs":return void ht(Be(wt(t[0])));case"pi":return void ht(Pe);case"sin":case"cos":case"tan":case"sqrt":case"round":case"floor":case"ceil":case"logn":case"log2":case"log10":return void ht({sin:Ee,cos:Ie,tan:je,sqrt:He,round:qe,floor:Ne,ceil:Se,logn:Te,log2:Fe,log10:Re}[e](wt(t[0])));case"and":return void xt(t.every(jt));case"or":return void xt(t.some(jt));case"odd?":case"even?":return void xt(wt(t[0])%2==("odd?"===e?1:0));case"pos?":case"neg?":case"zero?":{const r=wt(t[0]);return void xt("pos?"===e?r>0:"neg?"===e?r<0:!r)}case"null?":case"num?":case"bool?":case"str?":case"dict?":case"vec?":case"key?":case"func?":return void xt("null?"===e&&"null"===t[0].t||"num?"===e&&"num"===t[0].t||"bool?"===e&&"bool"===t[0].t||"str?"===e&&"str"===t[0].t||"dict?"===e&&"dict"===t[0].t||"vec?"===e&&"vec"===t[0].t||"key?"===e&&"key"===t[0].t||"func?"===e&&("func"===t[0].t||"clo"===t[0].t));case"has?":return void xt(Ye($t(t[0]),$t(t[1])));case"idx":{let e=-1;if("str"===t[0].t){if("str"!==t[1].t)return o("strings can only contain strings");if(!(lt(t)<3)){const e=$t(t[0]).split("");return e[wt(t[2])]=$t(t[1]),void bt(e.join(""))}e=Ze($t(t[0]),$t(t[1]))}else if("vec"===t[0].t){if(!(lt(t)<3)){const e=Pt(t[0]);return e[wt(t[2])]=t[1],void gt(e)}e=Bt(t[0]).findIndex((e=>St(e,t[1])))}return void(-1===e?Ct():ht(e))}case"map":case"for":case"reduce":case"filter":case"remove":case"find":case"count":{const s=Tt(r,t.shift(),n),a=e=>"vec"===e||"str"===e||"dict"===e,c="map"===e||"for"===e?t.findIndex((({t:e})=>!a(e))):a(t[0].t)?-1:0;if(-1!==c)return o(`argument 2 must be either: string, vector, dictionary, not ${J[t[c].t]}`);if("for"===e){const e=t.map(Pt),o=e.map(lt),a=o.map(((e,t)=>ze(o,0,t+1).reduce(((e,t)=>e*t))));a.unshift(1);const c=a.pop();if(c>r.loopBudget)return[{e:"Budget",m:"would exceed loop budget",errCtx:n}];const i=[];for(let t=0;t<c;++t){const r=a.map(((e,r)=>Ne(t/e%o[r]))),n=await s(e.map(((e,t)=>e[r[t]])));if(n)return n;i.push(vt.pop())}return void gt(i)}if("map"===e){const e=t.map(Pt),r=Oe(...e.map(lt)),n=[];for(let t=0;t<r;++t){const r=await s(e.map((e=>e[t])));if(r)return r;n.push(vt.pop())}return void gt(n)}const i=Pt(t.shift());if("reduce"!==e){const r="remove"===e,n="find"===e,o="count"===e,a=[];let c=0;for(let e=0,u=lt(i);e<u;++e){const u=await s([i[e],...t]);if(u)return u;const l=jt(vt.pop());if(o)c+=l?1:0;else{if(n&&l)return void vt.push(i[e]);n||l===r||a.push(i[e])}}switch(e){case"count":return void ht(c);case"find":return void Ct();default:return void gt(a)}}if(!lt(i))return void(lt(t)?vt.push(t[0]):gt());if(lt(i)<2&&!lt(t))return void Ke(vt,i);let u=(lt(t)?t:i).shift();for(let e=0,t=lt(i);e<t;++e){const t=await s([u,i[e]]);if(t)return t;u=vt.pop()}vt.push(u)}return;case"rand-int":case"rand":{const r=lt(t),[n,s]=[r<2?0:wt(t[0]),0===r?1+dt("rand-int"===e):wt(1===r?t[0]:t[1])];ht("rand-int"===e?ct(n,s):it(n,s))}return;case"do":case"val":return void vt.push("do"===e?t.pop():t.shift());case"..":case"...":{const s=Tt(r,t.shift(),n);let o=t;if(".."===e)o=_e(t.map((e=>"vec"===e.t?Bt(e):[e])));else{const e=o.pop();Ke(o,_e(["vec"===e.t?Bt(e):[e]]))}return await s(o)}case"into":{const e="vec"===t[0].t,r="vec"===t[1].t;if(e)gt(Le(Bt(t[0]),r?Bt(t[1]):Pt(t[1])));else if(r){const e=Pt(t[1]);vt.push(Ht(Le(_e(Pt(t[0]).map(Bt)),e)))}else{const{keys:e,vals:r}=It(t[0]),n=It(t[1]);At({keys:Le(e,n.keys),vals:Le(r,n.vals)})}return}case"push":if("vec"===t[0].t){const e=Bt(t[0]);if(lt(t)<3)gt(Le(e,[t[1]]));else{const r=wt(t[2]);gt(Le(Le(ze(e,0,r),[t[1]]),ze(e,r)))}}else lt(t)<3?vt.push((({keys:e,vals:t},r)=>{const[n,s]=[ze(e),ze(t)],o=e.findIndex((e=>St(e,r)));return-1!==o&&(Ue(n,o,1),Ue(s,o,1)),{t:"dict",v:{keys:n,vals:s}}})(It(t[0]),t[1])):At(Dt(It(t[0]),t[1],t[2]));return;case"sect":{const e=t[0],r="vec"===e.t,n=r?lt(Bt(e)):Qe($t(e));let s=0,o=n;switch(lt(t)){case 1:s=1;break;case 2:{const e=wt(t[1]);e<0?o+=e:s+=e;break}case 3:{const e=wt(t[1]),r=wt(t[2]);s=e<0?n+e+(r<0?r:0):s+e,o=(r<0?o:s)+r;break}}return s=De(s,0),o=Oe(o,n),s>o?void(r?gt:bt)():void(r?gt(ze(Bt(e),s,o)):bt(et($t(t[0]),s,o-s)))}case"reverse":return void("str"===t[0].t?bt(Mt(Ve(Pt(t[0])))):gt(Ve(Pt(t[0]))));case"sort":{if(!lt(Bt(t[0])))return void gt();const e=Pt(t[0]),s=[];if(1===lt(t))Ke(s,e.map((e=>[e,e])));else{const o=Tt(r,t.pop(),n);for(let t=0,r=lt(e);t<r;++t){const r=await o([e[t]]);if(r)return r;s.push([e[t],vt.pop()])}}const a=s[0][1].t;return s.some((([e,{t}])=>t!==a||!We(["num","str"],t)))?o("can only sort by all number or all string"):("num"===s[0][1].t?Ge(s,(([e,t],[r,n])=>wt(t)>wt(n)?1:-1)):Ge(s,(([e,t],[r,n])=>$t(t)>$t(n)?1:-1)),void gt(s.map((([e])=>e))))}case"range":{const[e,s,o]=t.map(wt),a=o&&o<0&&e<s,[c,i]=lt(t)>1?a?[s-1,e-1]:[e,s]:[0,e],u=Me((i-c)*(o||1))*(o||1),l=Se(Be((i-c)/u));if(!l)return void gt([]);if(l>r.rangeBudget)return[{e:"Budget",m:"range budget depleted",errCtx:n}];r.rangeBudget-=l;const p=mt(l).map((e=>e*u+c));return void gt(p.map((e=>({t:"num",v:e}))))}case"empty?":return void xt(!lt(Pt(t[0])));case"keys":case"vals":return void gt(It(t[0])["keys"===e?"keys":"vals"]);case"split":return void gt($t(t[0]).split(lt(t)>1?$t(t[1]):" ").map((e=>({t:"str",v:e}))));case"join":return void bt(Bt(t[0]).map(ft).join(lt(t)>1?$t(t[1]):" "));case"starts-with?":return void xt(Xe($t(t[0]),$t(t[1])));case"ends-with?":return void xt(Je($t(t[0]),$t(t[1])));case"upper-case":case"lower-case":case"trim":case"trim-start":case"trim-end":return void bt(("upper-case"===e?tt:"lower-case"===e?rt:"trim"===e?nt:"trim-start"===e?st:ot)($t(t[0])));case"str*":{const e=$t(t[0]);return void bt(mt(De(wt(t[1]),0)).map((t=>e)).join(""))}case"time":return void ht(at());case"version":return void ht(20211008);case"tests":{const e=await $e(Wt,!(lt(t)&&jt(t[0]))),s=e.pop();for(const t of e)await Ot("print",[{v:t,t:"str"}],r,n,!1);bt(s)}return;case"symbols":return void gt(function(e,t=!0){let r=t?["function"]:[];r=Le(r,pt(G)),r=Le(r,pt(e.env.funcs)),r=Le(r,pt(e.env.vars));const n=["entry"];return r.filter((e=>!We(n,e)))}(r,!1).map((e=>({t:"str",v:e}))));case"eval":{delete r.env.funcs.entry;const e=lt(vt),s=await Lt(r,$t(t[0]),n.invocationId);return s?(s.forEach((e=>{e.errCtx.invocationId="evaluated"})),[{e:"Eval",m:"error within evaluated code",errCtx:n},...s]):void(e===lt(vt)&&Ct())}case"reset":return r.env.vars={},r.env.funcs={},yt=[],void Ct()}var a;return[{e:"Unexpected",m:"operation doesn't exist",errCtx:n}]}function Tt(e,t,r,n=!0){const s=[{e:"Arity",m:"one argument required",errCtx:r}];if("str"===t.t||"func"===t.t){const o=t.v;return G[o]?t=>Ot(o,t,e,r,n):o in e.env.funcs?t=>Rt(e,e.env.funcs[o],t):o in e.env.vars?Tt(e,e.env.vars[o],r):o in yt[lt(yt)-1]?Tt(e,yt[lt(yt)-1][o],r):Xe(o,"$")?async t=>{if(!lt(t))return s;const n=await e.set(et(o,1),t[0]);return vt.push(t[0]),n?[{e:"External",m:n,errCtx:r}]:void 0}:async t=>{const{err:n,value:s}=await e.exe(o,t);return n||vt.push(s),n?[{e:"External",m:n,errCtx:r}]:void 0}}if("clo"===t.t)return r=>Rt(e,t.v,r);if("key"===t.t)return async e=>{if(!lt(e))return s;if("dict"===e[0].t)vt.push(qt(It(e[0]),t));else{if("vec"!==e[0].t)return Y(r,[e[0].t]);{const r=Bt(e[0]).find((e=>St(e,t)));vt.push(r??{t:"null",v:void 0})}}};if("num"===t.t){const e=Ne(t.v);return async t=>{if(!lt(t))return s;const n=t[0];if("str"!==n.t&&"vec"!==n.t&&"dict"!==n.t)return X(r,[n.t]);const o=Pt(n);Be(e)>=lt(o)?Ct():e<0?vt.push(o[lt(o)+e]):vt.push(o[e])}}if("vec"===t.t){const{v:e}=t;return async t=>{if(!lt(t))return s;const r=e.find((e=>St(e,t[0])));r?vt.push(r):Ct()}}if("dict"===t.t){const e=t.v;return async t=>{if(1===lt(t))vt.push(qt(e,t[0]));else{if(2!==lt(t))return[{e:"Arity",m:"dictionary as operation takes one or two arguments only",errCtx:r}];At(Dt(e,t[0],t[1]))}}}if("bool"===t.t){const e=t.v;return async t=>{if(!lt(t)||lt(t)>2)return[{e:"Arity",m:"boolean as operation takes one or two arguments only",errCtx:r}];vt.push(e?t[0]:lt(t)>1?t[1]:{t:"null",v:void 0})}}return async e=>[{e:"Operation",m:`${ft(t)} is an invalid operation`,errCtx:r}]}function Ft(e){const t=(e,t,r)=>Dt(e,{t:"key",v:t},r);return e.map((({e,m:r,errCtx:n})=>{let s=t({keys:[],vals:[]},":e",{t:"str",v:e});return s=t(s,":m",{t:"str",v:r}),s=t(s,":line",{t:"num",v:n.line}),s=t(s,":col",{t:"num",v:n.col}),{t:"dict",v:s}}))}async function Rt(e,t,r,n=!1){--e.callBudget,n||yt.push({});const s=lt(vt);for(let n=0,s=lt(t.ins);n<s;++n){const o=t.ins[n],{errCtx:a}=t.ins[n],c=e.loopBudget<1;if(c||e.callBudget<1)return[{e:"Budget",m:(c?"looped":"called")+" too many times",errCtx:a}];switch(o.typ){case"val":vt.push(o.value);break;case"var":e.env.vars[o.value]=vt[lt(vt)-1];break;case"let":yt[lt(yt)-1][o.value]=vt[lt(vt)-1];break;case"npa":case"upa":{const e=o.value;-1===e?gt(r):lt(r)<=e?Ct():vt.push(r[e])}break;case"ref":{const t=o.value;if(G[t])kt(t);else if(Xe(t,"$")){const{value:r,err:n}=await e.get(et(t,1));if(n)return[{e:"External",m:n,errCtx:a}];vt.push(r)}else if(t in e.env.vars)vt.push(e.env.vars[t]);else if(t in yt[lt(yt)-1])vt.push(yt[lt(yt)-1][t]);else{if(!(t in e.env.funcs))return[{e:"Reference",m:`"${t}" did not exist`,errCtx:a}];kt(t)}}break;case"exe":{const r=Tt(e,vt.pop(),a,!1),s=o.value,c=Ue(vt,lt(vt)-s,s),i=await r(c);if(i){const e=ze(t.ins,n).findIndex((e=>"cat"===e.typ));if(-1!==e){n+=e,yt[lt(yt)-1].errors={t:"vec",v:Ft(i)};break}return i}}break;case"or":jt(vt[lt(vt)-1])?n+=o.value:vt.pop();break;case"if":jt(vt.pop())||(n+=o.value);break;case"jmp":case"cat":n+=o.value;break;case"loo":n+=o.value,--e.loopBudget;break;case"pop":Ue(vt,lt(vt)-o.value,o.value);break;case"ret":o.value?Ue(vt,0,lt(vt)-1):Ct(),n=s;break;case"rec":{yt[lt(yt)-1]={},n=-1;const t=o.value;if(r=Ue(vt,lt(vt)-t,t),--e.recurBudget,!e.recurBudget)return[{e:"Budget",m:"recurred too many times",errCtx:a}]}continue;case"clo":case"par":{let[t,n]=o.value;const s=({typ:e,value:t})=>"ref"===e&&!n.find((e=>"let"===e.typ&&e.value===t))||"npa"===e,c={name:"",ins:n.filter(s)},i=await Rt(e,c,r,!0);if(i)return i;const u=lt(c.ins),l=Ue(vt,lt(vt)-u,u);if(n=n.map((e=>s(e)?{typ:"val",value:l.shift(),errCtx:a}:e)),"par"===o.typ){const{value:e,errCtx:t}=n.pop();n.unshift(n.pop()),n.push({typ:"upa",value:-1,errCtx:t}),n.push({typ:"val",value:{t:"str",v:"..."},errCtx:t}),n.push({typ:"exe",value:e+2,errCtx:t})}vt.push({t:"clo",v:{name:t,ins:n}})}}}n||(yt.pop(),Ue(vt,s,lt(vt)-(s+1)))}async function Lt(e,t,r){const n=ge(t,r);return lt(n.errors)?n.errors:(e.env.funcs={...e.env.funcs,...n.funcs},"entry"in e.env.funcs?await Rt(e,e.env.funcs.entry,[]):void 0)}async function Wt(e,t,r,n=!1){const{callBudget:s,loopBudget:o,recurBudget:a,rangeBudget:c}=e,i=await Lt(e,t,r);return e.callBudget=s,e.recurBudget=a,e.loopBudget=o,e.rangeBudget=c,delete e.env.funcs.entry,!i&&n&&lt(vt)&&await e.exe("print",[{t:"str",v:ft(vt[lt(vt)-1])}]),vt=[],yt=[],i??[]}const _t=new Map,Kt=/[\[\]\(\) ,]/;async function Vt(e,t){const r=H().toString();_t.set(r,t);const n=await Wt(e,t,r,!0);let s=[];return n.forEach((({e,m:t,errCtx:{line:r,col:n,invocationId:o}})=>{const a=_t.get(o);if(!a)return void s.push({type:"message",text:`${e} Error: line ${r} col ${n}: ${t}\n`});const i=a.split("\n")[r-1],u=l(i,n-1).split(Kt)[0],p=$(l(i,0,n-1));if(s.push({type:"message",text:I(`${r}`,4)+p}),u){const e=l(i,n-1+c(u));s.push({type:"error",text:u}),s.push({type:"message",text:`${e}\n`})}else{const e=l(i,n);s.push({type:"error",text:i[n-1]}),s.push({type:"message",text:`${e}\n`})}s.push({type:"message",text:`${e} Error: ${t}.\n`})})),s}window.insitux=t.invoker})();
//# sourceMappingURL=insitux.js.map