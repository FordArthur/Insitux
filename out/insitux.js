(()=>{"use strict";var e={607:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.symbols=t.invoke=t.exeFunc=t.visBoo=t.visKey=t.visFun=t.visDic=t.visVec=t.visNum=t.visStr=t.insituxVersion=void 0,t.insituxVersion=20210913;const n=r(306),s=r(17),{abs:a,cos:o,sin:i,tan:c,pi:u,sign:l,sqrt:p,floor:m,ceil:d,round:f,max:y,min:v}=s,{concat:x,has:h,flat:b,push:g,reverse:A,slice:C,splice:k,sortBy:w}=s,{ends:N,slen:$,starts:B,sub:M,subIdx:E,substr:I,upperCase:P,lowerCase:j}=s,{getTimeMs:H,randInt:q,randNum:D}=s,{isArray:S,isNum:O,len:T,objKeys:_,range:F,toNum:U}=s,V=r(127),K=r(699),R=({v:e,t})=>{switch(t){case"bool":case"num":return`${e}`;case"str":case"key":case"ref":return e;case"vec":return`[${e.map((e=>R(e))).join(" ")}]`;case"dict":{const{keys:t,vals:r}=e,[n,s]=[t.map(R),r.map(R)];return`{${n.map(((e,t)=>`${e} ${s[t]}`)).join(", ")}}`}case"null":return"null";case"func":return`<${e}>`}return(0,K.assertUnreachable)(t)};let L=[];const W=e=>L.push({t:"bool",v:e}),Z=e=>L.push({t:"num",v:e}),z=(e="")=>L.push({t:"str",v:e}),G=(e=[])=>L.push({t:"vec",v:e}),J=e=>L.push({t:"dict",v:e}),Q=()=>L.push({t:"null",v:void 0}),X=e=>L.push({t:"func",v:e}),Y=({v:e})=>e,ee=({v:e})=>e,te=({v:e})=>e,re=({v:e})=>e,ne=({t:e,v:t})=>"bool"===e?t:"null"!==e;t.visStr=e=>"str"===e.t,t.visNum=e=>"num"===e.t,t.visVec=e=>"vec"===e.t,t.visDic=e=>"dict"===e.t,t.visFun=e=>"func"===e.t,t.visKey=e=>"key"===e.t,t.visBoo=e=>"bool"==e.t;const se=({t:e,v:t})=>"vec"===e?C(t):"str"===e?[...t].map((e=>({t:"str",v:e}))):"dict"===e?t.keys.map(((e,r)=>({t:"vec",v:[e,t.vals[r]]}))):[],ae=e=>e.reduce(((e,t)=>e+R(t)),""),oe=e=>{T(e)%2==1&&e.pop();const t=e.filter(((e,t)=>t%2==0)),r=e.filter(((e,t)=>t%2==1)),n=[],s=[];return t.forEach(((e,t)=>{const a=n.findIndex((t=>ue(t,e)));-1===a?(n.push(e),s.push(r[t])):s[a]=r[t]})),{t:"dict",v:{keys:n,vals:s}}},ie=(e,t)=>({e:"Type",m:e,errCtx:t}),ce=(e,t)=>T(e)===T(t)&&!e.some(((e,r)=>!ue(e,t[r]))),ue=(e,t)=>{const{t:r}=e;switch(r){case"null":return!0;case"bool":return e.v===t.v;case"num":return Y(e)===Y(t);case"vec":return ce(te(e),te(t));case"dict":return((e,t)=>{const[r,n]=[re(e),re(t)];return T(r.keys)===T(n.keys)&&ce(r.keys,n.keys)})(e,t);case"str":case"ref":case"key":case"func":return ee(e)===ee(t)}return(0,K.assertUnreachable)(r)},le=({keys:e,vals:t},r)=>{const n=e.findIndex((e=>ue(e,r)));return-1===n?{t:"null",v:void 0}:t[n]};async function pe(e,r,n,s){const k=e=>[ie(e,s)];{const t=function(e,t,r){const{types:n,exactArity:s,maxArity:a,minArity:o,onlyNum:i}=K.ops[e],c=(t,n)=>[{e:"Arity",m:`${e} needs ${t} argument${1!==n?"s":""}`,errCtx:r}],u=T(t);if(void 0!==s){if(u!==s)return c(`exactly ${s}`,s)}else{if(o&&!a&&u<o)return c(`at least ${o}`,o);if(!o&&a&&u>a)return c(`at most ${a}`,a);if(o&&a&&(u<o||u>a))return c(`between ${o} and ${a}`,a)}return i?-1!==t.findIndex((e=>"num"!==e.t))?[ie("numeric arguments only",r)]:[]:n?n.map(((e,r)=>r<u&&(S(e)?!h(e,t[r].t)&&`argument ${r+1} must be either: ${e.map((e=>K.typeNames[e])).join(", ")}`:e!==t[r].t&&`argument ${r+1} must be ${K.typeNames[e]}`))).filter((e=>!!e)).map((e=>ie(e,r))):[]}(e,r,s);if(T(t))return t}switch(e){case"execute-last":return await me(n,r.pop(),s)(r);case"str":return L.push({t:"str",v:ae(r)}),[];case"print":case"print-str":return n.exe(e,[{t:"str",v:ae(r)}]),Q(),[];case"vec":return G(r),[];case"dict":return L.push(oe(r)),[];case"len":return Z("str"===r[0].t?$(ee(r[0])):"vec"===r[0].t?T(te(r[0])):T(re(r[0]).keys)),[];case"num":return O(r[0].v)?Z(U(r[0].v)):Q(),[];case"!":return W(!ne(r[0])),[];case"=":case"!=":for(let t=1,n=T(r);t<n;++t)if(ue(r[t-1],r[t])!==("="===e))return W(!1),[];return W(!0),[];case"-":return Z(1===T(r)?-Y(r[0]):r.map(Y).reduce(((e,t)=>e-t))),[];case"**":return Z(Y(r[0])**(1===T(r)?2:Y(r[1]))),[];case"+":return Z(r.map(Y).reduce(((e,t)=>e+t))),[];case"*":return Z(r.map(Y).reduce(((e,t)=>e*t))),[];case"/":return Z(r.map(Y).reduce(((e,t)=>e/t))),[];case"//":return Z(r.map(Y).reduce(((e,t)=>m(e/t)))),[];case"rem":return Z(r.map(Y).reduce(((e,t)=>e%t))),[];case"min":return Z(r.map(Y).reduce(((e,t)=>v(e,t)))),[];case"max":return Z(r.map(Y).reduce(((e,t)=>y(e,t)))),[];case"<":case">":case"<=":case">=":for(let t=1,n=T(r);t<n;++t){const[n,s]=[r[t-1].v,r[t].v];if("<"===e&&n>=s||">"===e&&n<=s||"<="===e&&n>s||">="===e&&n<s)return W(!1),[]}return W(!0),[];case"inc":return Z(r[0].v+1),[];case"dec":return Z(r[0].v-1),[];case"abs":return Z(a(Y(r[0]))),[];case"pi":return Z(u),[];case"sin":case"cos":case"tan":case"sqrt":case"round":case"floor":case"ceil":return Z({sin:i,cos:o,tan:c,sqrt:p,round:f,floor:m,ceil:d}[e](Y(r[0]))),[];case"odd?":case"even?":return W(Y(r[0])%2==("odd?"===e?1:0)),[];case"pos?":case"neg?":case"zero?":{const t=Y(r[0]);return W("pos?"===e?t>0:"neg?"===e?t<0:!t),[]}case"null?":case"num?":case"bool?":case"str?":case"dict?":case"vec?":case"key?":case"func?":return W("null?"===e&&"null"===r[0].t||"num?"===e&&"num"===r[0].t||"bool?"===e&&"bool"===r[0].t||"str?"===e&&"str"===r[0].t||"dict?"===e&&"dict"===r[0].t||"vec?"===e&&"vec"===r[0].t||"key?"===e&&"key"===r[0].t||"func?"===e&&"func"===r[0].t),[];case"has?":return W(M(ee(r[0]),ee(r[1]))),[];case"idx":{let e=-1;if("str"===r[0].t){if("str"!==r[1].t)return k("strings can only contain strings");e=E(ee(r[0]),ee(r[1]))}else"vec"===r[0].t&&(e=te(r[0]).findIndex((e=>ue(e,r[1]))));return-1===e?Q():Z(e),[]}case"map":case"for":case"reduce":case"filter":{const t=me(n,r.shift(),s),a=e=>"vec"===e||"str"===e||"dict"===e;if(-1!==("map"===e||"for"===e?r.findIndex((({t:e})=>!a(e))):a(r[0].t)?-1:0))return k("argument 2 must be either: string, vector, dictionary");if("for"===e){const e=r.map(se),a=e.map(T),o=a.map(((e,t)=>C(a,0,t+1).reduce(((e,t)=>e*t))));o.unshift(1);const i=o.pop();if(i>n.loopBudget)return[{e:"Budget",m:"would exceed loop budget",errCtx:s}];const c=[];for(let r=0;r<i;++r){const n=o.map(((e,t)=>m(r/e%a[t]))),s=await t(e.map(((e,t)=>e[n[t]])));if(T(s))return s;c.push(L.pop())}return G(c),[]}if("map"===e){const e=r.map(se),n=v(...e.map((e=>T(e)))),s=[];for(let r=0;r<n;++r){const n=await t(e.map((e=>e[r])));if(T(n))return n;s.push(L.pop())}return G(s),[]}const o=se(r.shift());if("filter"===e){const e=[];for(let r=0,n=T(o);r<n;++r){const n=await t([o[r]]);if(T(n))return n;ne(L.pop())&&e.push(o[r])}return G(e),[]}if(T(o)<2)return g(L,o),[];let i=(T(r)?r:o).shift();for(let e=0,r=T(o);e<r;++e){const r=await t([i,o[e]]);if(T(r))return r;i=L.pop()}L.push(i)}return[];case"rand-int":case"rand":{const t=T(r),[n,s]=[t<2?0:Y(r[0]),0===t?1+U("rand-int"===e):Y(1===t?r[0]:r[1])];Z("rand-int"===e?q(n,s):D(n,s))}return[];case"do":case"val":return L.push("do"===e?r.pop():r.shift()),[];case"..":{const e=me(n,r.shift(),s);return await e(b(r.map((e=>"vec"===e.t?te(e):[e]))))}case"into":{const e="vec"===r[0].t,t="vec"===r[1].t;if(e)G(x(te(r[0]),t?te(r[1]):se(r[1])));else if(t){const e=se(r[1]);L.push(oe(x(b(se(r[0]).map(te)),e)))}else{const{keys:e,vals:t}=re(r[0]),n=re(r[1]);J({keys:x(e,n.keys),vals:x(t,n.vals)})}return[]}case"push":if("vec"===r[0].t)G(x(se(r[0]),[r[1]]));else{if(T(r)<3)return[{e:"Arity",m:"key and value both required",errCtx:s}];const{keys:e,vals:t}=re(r[0]);J({keys:x(e,[r[1]]),vals:x(t,[r[2]])})}return[];case"sect":{const e=r[0],t="vec"===e.t,n=t?T(te(e)):$(ee(e));let s=0,a=n;switch(T(r)){case 1:s=1;break;case 2:{const e=Y(r[1]);e<0?a+=e:s+=e;break}case 3:{const e=Y(r[1]),t=Y(r[2]);s=e<0?n+e+(t<0?t:0):s+e,a=(t<0?a:s)+t;break}}return s=y(s,0),a=v(a,n),s>a?((t?G:z)(),[]):(t?G(C(te(e),s,a)):z(I(ee(r[0]),s,a-s)),[])}case"reverse":return"str"===r[0].t?z(ae(A(se(r[0])))):G(A(se(r[0]))),[];case"sort":{if(!T(te(r[0])))return G(),[];const e=se(r[0]),a=[];if(1===T(r))g(a,e.map((e=>[e,e])));else{const t=me(n,r.pop(),s);for(let r=0,n=T(e);r<n;++r){const n=await t([e[r]]);if(T(n))return n;a.push([e[r],L.pop()])}}const o=a[0][1].t;return a.some((([e,{t}])=>t!==o||!h(["num","str"],t)))?k("can only sort by all number or all string"):((0,t.visNum)(a[0][1])?w(a,(([e,t],[r,n])=>Y(t)>Y(n)?1:-1)):w(a,(([e,t],[r,n])=>ee(t)>ee(n)?1:-1)),G(a.map((([e])=>e))),[])}case"range":{const[e,t,o]=r.map(Y),i=o&&o<0&&e<t,[c,u]=T(r)>1?i?[t-1,e-1]:[e,t]:[0,e],p=l((u-c)*(o||1))*(o||1),m=d(a((u-c)/p));if(!m)return G([]),[];if(m>n.rangeBudget)return[{e:"Budget",m:"range budget depleted",errCtx:s}];n.rangeBudget-=m;const f=F(m).map((e=>e*p+c));return G(f.map((e=>({t:"num",v:e})))),[]}case"empty?":return W(!T(se(r[0]))),[];case"keys":case"vals":return G(re(r[0])["keys"===e?"keys":"vals"]),[];case"split":return G(ee(r[0]).split(T(r)>1?ee(r[1]):" ").map((e=>({t:"str",v:e})))),[];case"join":return z(te(r[0]).map(R).join(T(r)>1?ee(r[1]):" ")),[];case"starts-with?":return W(B(ee(r[0]),ee(r[1]))),[];case"ends-with?":return W(N(ee(r[0]),ee(r[1]))),[];case"upper-case":return z(P(ee(r[0]))),[];case"lower-case":return z(j(ee(r[0]))),[];case"time":return Z(H()),[];case"version":return Z(t.insituxVersion),[];case"tests":{const e=await(0,V.doTests)(ye,!(T(r)&&ne(r[0]))),t=e.pop();for(const t of e)await pe("print",[{v:t,t:"str"}],n,s);z(t)}return[];case"eval":{delete n.env.funcs.entry;const e=T(L),t=await fe(n,ee(r[0]),s.invocationId);return T(t)?[{e:"Eval",m:"error within evaluated code",errCtx:s}]:(e===T(L)&&Q(),[])}}return[{e:"Unexpected",m:"operation doesn't exist",errCtx:s}]}function me(e,r,n){const s=[{e:"Arity",m:"one argument required",errCtx:n}];if((0,t.visStr)(r)||(0,t.visFun)(r)){const t=r.v;return K.ops[t]?r=>pe(t,r,e,n):t in e.env.funcs?r=>de(e,e.env.funcs[t],r):t in e.env.vars?me(e,e.env.vars[t],n):t in e.env.lets[T(e.env.lets)-1]?me(e,e.env.lets[T(e.env.lets)-1][t],n):B(t,"$")?async r=>{if(!T(r))return s;const a=await e.set(I(t,1),r[0]);return L.push(r[0]),a?[{e:"External",m:a,errCtx:n}]:[]}:async r=>{const{err:s,value:a}=await e.exe(t,r);return s||L.push(a),s?[{e:"External",m:s,errCtx:n}]:[]}}if((0,t.visKey)(r))return async e=>T(e)?"dict"!==e[0].t?[ie("argument 1 must be dictionary",n)]:(L.push(le(re(e[0]),r)),[]):s;if((0,t.visNum)(r)){const e=r.v;return async t=>{if(!T(t))return s;const r=t[0];if("str"!==r.t&&"vec"!==r.t&&"dict"!==r.t)return[ie("argument must be string, vector, or dictionary",n)];const o=se(r);return a(e)>=T(o)?Q():e<0?L.push(o[T(o)+e]):L.push(o[e]),[]}}if((0,t.visVec)(r)){const{v:e}=r;return async t=>{if(!T(t))return s;const r=e.find((e=>ue(e,t[0])));return r?L.push(r):Q(),[]}}if((0,t.visDic)(r)){const e=r.v;return async t=>{if(1===T(t))L.push(le(e,t[0]));else{if(2!==T(t))return[{e:"Arity",m:"dict as operation takes one or two arguments only",errCtx:n}];L.push((({keys:e,vals:t},r,n)=>{const[s,a]=[C(e),C(t)],o=e.findIndex((e=>ue(e,r)));return-1!==o?a[o]=n:(s.push(r),a.push(n)),{t:"dict",v:{keys:s,vals:a}}})(e,t[0],t[1]))}return[]}}if((0,t.visBoo)(r)){const e=r.v;return async t=>!T(t)||T(t)>2?[{e:"Arity",m:"boolean as operation takes one or two arguments only",errCtx:n}]:(L.push(e?t[0]:T(t)>1?t[1]:{t:"null",v:void 0}),[])}return async e=>[{e:"Operation",m:`${R(r)} is an invalid operation`,errCtx:n}]}async function de(e,r,n){--e.callBudget,e.env.lets.push({});for(let a=0,o=T(r.ins);a<o;++a){const{typ:i,value:c,errCtx:u}=r.ins[a],l=e.loopBudget<1;if(l||e.callBudget<1)return[{e:"Budget",m:(l?"looped":"called")+" too many times",errCtx:u}];switch(i){case"nul":Q();break;case"boo":W(c);break;case"num":Z(c);break;case"str":z(c);break;case"key":s=c,L.push({t:"key",v:s});break;case"var":e.env.vars[c]=L[T(L)-1];break;case"let":e.env.lets[T(e.env.lets)-1][c]=L[T(L)-1];break;case"par":{const e=c;-1===e?G(n):T(n)<=e?Q():L.push(n[e])}break;case"ref":{const t=c;if(K.ops[t])X(t);else if(B(t,"$")){const{value:r,err:n}=await e.get(I(t,1));if(n)return[{e:"External",m:n,errCtx:u}];L.push(r)}else if(t in e.env.vars)L.push(e.env.vars[t]);else if(t in e.env.lets[T(e.env.lets)-1])L.push(e.env.lets[T(e.env.lets)-1][t]);else{if(!(t in e.env.funcs))return[{e:"Reference",m:`"${t}" did not exist`,errCtx:u}];X(t)}}break;case"op":case"exe":{let[s,i]=c;const l=k(L,T(L)-i,i);if(T(l)!==i)return[{e:"Unexpected",m:`${s} stack depleted`,errCtx:u}];if(a===o-1&&(0,t.visStr)(s)&&s.v===r.name){if(e.env.lets[T(e.env.lets)-1]={},a=-1,n=l,--e.recurBudget,!e.recurBudget)return[{e:"Budget",m:"recurred too many times",errCtx:u}];continue}const p=me(e,s,u),m=await p(l);if(T(m))return m}break;case"or":ne(L[T(L)-1])?a+=c:L.pop();break;case"if":ne(L.pop())||(a+=c);break;case"jmp":a+=c;break;case"loo":a+=c,--e.loopBudget;break;case"pop":k(L,T(L)-c,c);break;case"ret":k(L,0,T(L)-1),a=o;break;default:(0,K.assertUnreachable)(i)}}var s;return e.env.lets.pop(),[]}async function fe(e,t,r){const s=(0,n.parse)(t,r);return T(s.errors)?s.errors:(e.env.funcs={...e.env.funcs,...s.funcs},"entry"in e.env.funcs?await de(e,e.env.funcs.entry,[]):[])}async function ye(e,t,r,n=!1){const{callBudget:s,loopBudget:a,recurBudget:o,rangeBudget:i}=e,c=await fe(e,t,r);return e.env.lets=[],e.callBudget=s,e.recurBudget=o,e.loopBudget=a,e.rangeBudget=i,delete e.env.funcs.entry,!T(c)&&n&&T(L)&&await e.exe("print",[{t:"str",v:R(L[T(L)-1])}]),L=[],c}t.exeFunc=de,t.invoke=ye,t.symbols=function(e){let t=["function"];return t=x(t,_(K.ops).filter((e=>"execute-last"!==e))),t=x(t,_(e.env.funcs)),t=x(t,_(e.env.vars)),t}},669:(e,t,r)=>{t.invoker=t.Z=void 0;const n=r(607),s=r(17),a=new Map;t.Z=/[\[\]\(\) ]/,t.invoker=async function(e,r){const o=(0,s.getTimeMs)().toString();a.set(o,r);const i=await(0,n.invoke)(e,r,o,!0);let c=[];return i.forEach((({e,m:r,errCtx:{line:n,col:o,invocationId:i}})=>{const u=a.get(i).split("\n")[n-1],l=(0,s.substr)(u,o-1).split(t.Z)[0],p=(0,s.trimStart)((0,s.substr)(u,0,o-1));if(c.push({type:"message",text:(0,s.padEnd)(`${n}`,4)+p}),l){const e=(0,s.substr)(u,o-1+l.length);c.push({type:"error",text:l}),c.push({type:"message",text:`${e}\n`})}else{const e=(0,s.substr)(u,o);c.push({type:"error",text:u[o-1]}),c.push({type:"message",text:`${e}\n`})}c.push({type:"message",text:`${e} Error: ${r}.\n`})})),c}},306:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parse=void 0;const n=r(17),{concat:s,has:a,flat:o,push:i,slice:c}=n,{slen:u,starts:l,sub:p,substr:m,strIdx:d}=n,{isNum:f,len:y,toNum:v}=n,x=r(699),h=r(699);function b(e,t){if(!y(e))return[];const{typ:r,text:n,errCtx:s}=e.shift();switch(r){case"str":return[{typ:"str",value:n,errCtx:s}];case"num":return[{typ:"num",value:v(n),errCtx:s}];case"sym":if("true"===n||"false"===n)return[{typ:"boo",value:"true"===n,errCtx:s}];if("null"===n)return[{typ:"nul",value:void 0,errCtx:s}];if(l(n,":"))return[{typ:"key",value:n,errCtx:s}];if(l(n,"#")&&f(m(n,1))){const e=v(m(n,1));return e<0?[{typ:"nul",errCtx:s}]:[{typ:"par",value:e,errCtx:s}]}return a(t,n)?[{typ:"par",value:t.indexOf(n),errCtx:s}]:"args"===n?[{typ:"par",value:-1,errCtx:s}]:[{typ:"ref",value:n,errCtx:s}];case"ref":return[{typ:"def",value:n,errCtx:s}];case"(":return function(e,t){const r=e.shift();if(!r)return[];const{typ:n,text:s,errCtx:o}=r;let c=s;const u=e=>[{typ:"err",value:e,errCtx:o}];if("var"===c||"let"===c){const[r,n]=[b(e,t),b(e,t)];return y(r)&&y(n)&&!y(b(e,t))?[...n,{typ:c,value:r[0].value,errCtx:o}]:u("must provide reference name and value only")}if("if"===c||"when"===c){const r=b(e,t);if(!y(r))return u("must provide condition");const n=r;if("if"===c){const r=b(e,t);if(!y(r))return u("must provide a branch");n.push({typ:"if",value:y(r)+1,errCtx:o}),i(n,r);const s=b(e,t);if(y(s)){if(n.push({typ:"jmp",value:y(s),errCtx:o}),i(n,s),y(b(e,t)))return u("too many branches")}else n.push({typ:"jmp",value:1,errCtx:o}),n.push({typ:"nul",value:void 0,errCtx:o})}else{const r=[];for(;;){const n=b(e,t);if(!y(n))break;i(r,n)}n.push({typ:"if",value:y(r)+1,errCtx:o}),i(n,r),n.push({typ:"jmp",value:1,errCtx:o}),n.push({typ:"nul",value:void 0,errCtx:o})}return n}if("and"===c||"or"===c||"while"===c){const r=[];let n=0;for(;;){const s=b(e,t);if(!y(s))break;r.push(s),n+=y(s)}if(y(r)<2)return u("requires at least two arguments");const s=[];if("while"===c){n+=2;const e=r.shift();return i(s,e),s.push({typ:"if",value:n-y(e),errCtx:o}),r.forEach((e=>i(s,e))),s.push({typ:"pop",value:y(r),errCtx:o}),s.push({typ:"loo",value:-(n+1),errCtx:o}),s}n+=y(r),n+=v("and"===c);const a="and"===c?"if":"or";for(let e=0;e<y(r);++e)i(s,r[e]),n-=y(r[e]),s.push({typ:a,value:n,errCtx:o}),--n;return"and"===c?i(s,[{typ:"boo",value:!0,errCtx:o},{typ:"jmp",value:1,errCtx:o},{typ:"boo",value:!1,errCtx:o}]):s.push({typ:"boo",value:!1,errCtx:o}),s}const p=[];let m=0;if("("===n||a(t,s)||l(s,"#")){e.unshift(r);const n=b(e,t);i(p,n),c="execute-last",++m}const d=[];for(;y(e);){const r=b(e,t);if(!y(r))break;++m,i(d,r)}return"return"===c?[...d,{typ:"ret",errCtx:o}]:(p.push({typ:x.ops[c]?"op":"exe",value:["num"===n?{t:"num",v:v(c)}:l(c,":")?{t:"key",v:c}:x.ops[c]?{t:"func",v:c}:"true"===c||"false"===c?{t:"bool",v:"true"===c}:{t:"str",v:c},m],errCtx:o}),[...d,...p])}(e,t);case")":return[];default:return(0,h.assertUnreachable)(r)}}t.parse=function(e,t){const{tokens:r,stringError:n}=function(e,t){const r=[];let n=!1,s=!1,a=[0,0],o=!1,i=!1,c=!1,l=1,m=0;for(let f=0,v=u(e);f<v;++f){const u=d(e,f),x=f+1!==v?d(e,f+1):"";if(++m,c){"\n"===u&&(c=!1,++l,m=0);continue}if(s){s=!1,n&&(r[y(r)-1].text+={n:"\n",t:"\t"}[u]||`\\${u}`);continue}if("\\"===u){s=!0;continue}if('"'===u){(n=!n)&&(a=[l,m],r.push({typ:"str",text:"",errCtx:{invocationId:t,line:l,col:m}})),i=o=!1;continue}const h=p(" \t\n\r",u);if(!n&&h){i=o=!1,"\n"===u&&(++l,m=0);continue}if(!n&&";"===u){c=!0;continue}const b={invocationId:t,line:l,col:m},g=e=>p("0123456789",e),A=p("()[]{}",u);if(i&&!g(u)&&(i="."===u&&!p(r[y(r)-1].text,"."),i||A||h||(o=!0,r[y(r)-1].typ="sym")),o&&A&&(o=!1),!n&&!o&&!i){if(A){const e={"[":"(","{":"(","(":"(",")":")","}":")","]":")"}[u];r.push({typ:e,text:e,errCtx:b}),"["===u?r.push({typ:"sym",text:"vec",errCtx:b}):"{"===u&&r.push({typ:"sym",text:"dict",errCtx:b});continue}i=g(u)||"."===u&&g(x)||"-"===u&&(g(x)||"."===x),o=!i;let e=o?"sym":"num";if(y(r)){const{typ:t,text:n}=r[y(r)-1];"sym"!==t||"var"!==n&&"let"!==n||(e="ref")}r.push({typ:e,text:"",errCtx:b})}r[y(r)-1].text+=u}return{tokens:r,stringError:n?a:void 0}}(e,t),a=function(e,t,r){const n=[],s=(e,t)=>n.push({e:"Parse",m:e,errCtx:t}),a=e=>y(t.filter((({typ:t})=>t===e))),[o,i]=[a("("),a(")")];{const[e,n]=function(e,t,r){const n=r>=t,[s,a]=[n?"(":")",n?")":"("],o=n?1:-1;for(let t=y(e),r=n?0:t-1,i=0;n?r<t:r>=0;r+=o){const{typ:t,errCtx:{line:n,col:o}}=e[r];if(i+=v(t===s)-v(t===a),i<0)return[n,o]}return[0,0]}(t,o,i);e+n&&s("unmatched parenthesis",{invocationId:r,line:e,col:n})}if(e){const[t,n]=e;s("unmatched double quotation marks",{invocationId:r,line:t,col:n})}let c;for(let e=0,r=!1;e<y(t);++e){if(r&&")"===t[e].typ){c=t[e];break}r="("===t[e].typ}return c&&s("empty expression forbidden",c.errCtx),n}(n,r,t);if(y(a))return{errors:a,funcs:{}};const l=function(e){const t=e=>y(e)>1&&"sym"===e[1].typ&&"function"===e[1].text,r=e.filter((e=>t(e))),n=o(e.filter((e=>!t(e)))),a=r.map((e=>({name:e[2].text,tokens:c(e,3),errCtx:e[2].errCtx})));return y(n)?s(a,[{name:"entry",tokens:n,errCtx:n[0].errCtx}]):a}(function(e){const t=[[]];let r=0;return e.forEach((e=>{t[y(t)-1].push(e),r+=v("("===e.typ)-v(")"===e.typ),0===r&&t.push([])})),t}(r)).map((e=>function({name:e,tokens:t},r){const[n,s]=function(e,t){const r=[],n=[];for(let t=0,s=!1;t<y(e);++t)s||(s="sym"!==e[t].typ),(s?n:r).push(e[t]);return[r,n]}(t);if(!y(n)&&!y(s))return{err:{e:"Parse",m:"empty function body",errCtx:r}};if(y(s)&&")"===s[0].typ){if(!y(n))return{err:{e:"Parse",m:"empty function body",errCtx:r}};s.unshift(n.pop())}y(n)&&!y(s)&&s.push(n.pop());const a=[];for(;y(s);)i(a,b(s,n.map((e=>e.text))));const o=a.filter((e=>"err"===e.typ));return y(o)?{err:{e:"Parse",m:o[0].value,errCtx:o[0].errCtx}}:{func:{name:e,ins:a}}}(e,{invocationId:t,line:e.errCtx.line,col:e.errCtx.col}))),[m,f]=function(e,t){const r=[],n=[];return e.forEach((e=>{return(t=e,t.err?n:r).push(e);var t})),[r,n]}(l);i(a,f.map((e=>e.err)));const x={};return m.forEach((({func:e})=>x[e.name]=e)),{errors:a,funcs:x}}},17:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.pi=t.sign=t.ceil=t.floor=t.round=t.sqrt=t.tan=t.cos=t.sin=t.max=t.min=t.abs=t.getTimeMs=t.objKeys=t.range=t.randInt=t.randNum=t.padEnd=t.upperCase=t.lowerCase=t.trimStart=t.trim=t.reverse=t.sortBy=t.push=t.concat=t.flat=t.ends=t.starts=t.has=t.subIdx=t.sub=t.strIdx=t.substr=t.isArray=t.isNum=t.slen=t.len=t.splice=t.slice=t.toNum=void 0,t.toNum=e=>Number(e),t.slice=(e,t,r)=>e.slice(t,r),t.splice=(e,t,r)=>e.splice(t,r),t.len=e=>e.length,t.slen=e=>e.length,t.isNum=e=>!Number.isNaN(Number(e)),t.isArray=e=>Array.isArray(e),t.substr=(e,t,r)=>e.substring(t,t+(r??e.length)),t.strIdx=(e,t)=>e[t],t.sub=(e,t)=>e.includes(t),t.subIdx=(e,t)=>e.indexOf(t),t.has=(e,t)=>e.includes(t),t.starts=(e,t)=>e.startsWith(t),t.ends=(e,t)=>e.endsWith(t),t.flat=e=>e.flat(),t.concat=(e,t)=>e.concat(t),t.push=(e,t)=>e.push(...t),t.sortBy=(e,t)=>e.sort(t),t.reverse=e=>e.reverse(),t.trim=e=>e.trim(),t.trimStart=e=>e.trimStart(),t.lowerCase=e=>e.toLowerCase(),t.upperCase=e=>e.toUpperCase(),t.padEnd=(e,t)=>e.padEnd(t),t.randNum=(e,t)=>e+Math.random()*(t-e),t.randInt=(e,r)=>Math.floor((0,t.randNum)(e,r)),t.range=e=>[...Array(e).keys()],t.objKeys=e=>Object.keys(e),t.getTimeMs=()=>(new Date).getTime(),t.abs=Math.abs,t.min=Math.min,t.max=Math.max,t.sin=Math.sin,t.cos=Math.cos,t.tan=Math.tan,t.sqrt=Math.sqrt,t.round=Math.round,t.floor=Math.floor,t.ceil=Math.ceil,t.sign=Math.sign,t.pi=Math.PI},127:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.doTests=void 0;const n=r(17);async function s(e,t){return e.dict.has(t)?{value:e.dict.get(t),err:void 0}:{value:{t:"null",v:void 0},err:`"${t} not found.`}}async function a(e,t,r){e.dict.set(t,r)}async function o(e,t,r){const n={t:"null",v:void 0};switch(t){case"print-str":e.output+=r[0].v;break;case"print":case"test.function":e.output+=r[0].v+"\n";break;default:return{value:n,err:"operation does not exist"}}return{value:n,err:void 0}}const i=[{name:"Hello, world!",code:'"Hello, world!"',out:"Hello, world!"},{name:"Say Hello, world!",code:'(print "Hello, world!")',out:"Hello, world!\nnull"},{name:"1 + 1 = 2",code:"(+ 1 1)",out:"2"},{name:"Negate 1 = -1",code:"(- 1)",out:"-1"},{name:"(1+1)+1+(1+1) = 5",code:"(+ (+ 1 1) 1 (+ 1 1))",out:"5"},{name:"Conditional head",code:"((if true + -) 12 9 1)",out:"22"},{name:"Whens",code:'[(when 123 (print "hi") 234) (when false (print "bye"))]',out:"hi\n[234 null]"},{name:"Cond number head",code:"((if false 1 2) [:a :b :c])",out:":c"},{name:"and & short-circuit",code:"[(and true (if true null 1) true) (and 1 2 3)]",out:"[false true]"},{name:"or & short-circuit",code:'[(or true (print "hello") 1) (or false (print-str "-> ") 1)]',out:"-> [true 1]"},{name:"String retrieve",code:'(2 "Hello")',out:"l"},{name:"Vector retrieve",code:"(2 [:a :b :c :d])",out:":c"},{name:"Key as operation",code:'(:age {:name "Patrick" :age 24})',out:"24"},{name:"Dictionary as op 1",code:'({"name" "Patrick" "age" 24} "age")',out:"24"},{name:"Dictionary as op 2",code:'({"name" "Patrick"} "age" 24)',out:"{name Patrick, age 24}"},{name:"Equalities",code:'[(= 1 2 1)\n            (!= 1 2 1)\n            (= "Hello" "hello")\n            (!= "world" "world")\n            (= [0 [1]] [0 [1]])]',out:"[false true false false true]"},{name:"Define and retrieve",code:"(var a 1) a",out:"1"},{name:"Define and add",code:"(var a 1) (inc a)",out:"2"},{name:"Define op and call",code:"(var f +) (f 2 2)",out:"4"},{name:"Define vec and call",code:"(var f [1]) (f 1)",out:"1"},{name:"Define num and call",code:"(var f 1) (f [:a :b :c])",out:":b"},{name:"Print simple vector",code:"[1 2 3]",out:"[1 2 3]"},{name:"Boolean select",code:"[(true 1 2) (false 1)]",out:"[1 null]"},{name:"Sum vector of numbers",code:"[(reduce + [1 2 3]) (reduce + [1 2 3] 3)]",out:"[6 9]"},{name:"Sum vectors of numbers",code:"(map + [1 2 3] [1 2 3 4])",out:"[2 4 6]"},{name:"Filter by integer",code:'(filter 2 [[1] [:a :b :c] "hello" "hi"])',out:"[[:a :b :c] hello]"},{name:"Comments, short decimal",code:';((print "Hello")\n           .456',out:"0.456"},{name:"Dictionary into vector",code:"(into [1 2] {3 4 5 6})",out:"[1 2 [3 4] [5 6]]"},{name:"Vector into dictionary",code:"(into {[0] 1 [2] 3} [[0] 2])",out:"{[0] 2, [2] 3}"},{name:"While loop",code:"(var n 5)\n           (while (< 0 n)\n             (print-str n)\n             (var n (dec n)))",out:"543215"},{name:"Define with no call",code:'(function func (print "Nothing."))'},{name:"Call greet func",code:'(function greeting (print "Hello!")) (greeting)',out:"Hello!\nnull"},{name:"Call const value func",code:"(function const 123) (const)",out:"123"},{name:"Call identity funcs",code:"(function id1 #)\n           (function id2 x x)\n           [(id1 123) (id2 456)]",out:"[123 456]"},{name:"Call greet with name",code:'(function greeting name (print "Hello, " name "!"))\n           (greeting "Patrick")',out:"Hello, Patrick!\nnull"},{name:"Call with too few args",code:"(function func a b c [a b c]) (func 1 2)",out:"[1 2 null]"},{name:"Define func and call",code:"(function func a b (+ a b)) (var f func) (f 2 2)",out:"4"},{name:"Anonymous parameters",code:"(function avg<n? (< (/ (.. + #) (len #)) #1))\n           (avg<n? [0 10 20 30 40] 5)",out:"false"},{name:"Call parameter",code:'(function f x (x "hello")) (f print)',out:"hello\nnull"},{name:"Let and retrieve",code:"(function f (let a 1) a) (f)",out:"1"},{name:"Let num op and call",code:"(function f (let n 0) (n [0])) (f)",out:"0"},{name:"Explicit return",code:"(function f (return 123) (print 456)) (f)",out:"123"},{name:"String instead of number",code:'(function sum (.. + args))\n           (print (sum 2 2))\n           (sum 2 "hi")',out:"4",err:["Type"]},{name:"Reference non-existing",code:"x",err:["Reference"]},{name:"Expired let retrieve",code:"(function f (let a 1) a) (f) a",err:["Reference"]},{name:"Call non-existing",code:"(x)",err:["External"]},{name:"Call budget",code:"(function f (f)) (f)",err:["Budget"]},{name:"Loop budget",code:"(var n 10000)\n           (while (< 0 n)\n             (var n (dec n)))",err:["Budget"]},{name:"Range budget",code:"(range 10000)",err:["Budget"]},{name:"Fibonacci 13",code:"(function fib n\n             (if (< n 2) n\n               (+ (fib (dec n))\n                  (fib (- n 2)))))\n           (fib 13)",out:"233"},{name:"dedupe (tail-call optim)",code:"(function dedupe list -out\n             (let out (or -out []))\n             (let next (if (out (0 list)) [] [(0 list)]))\n             (if (empty? list) out\n                 (dedupe (sect list) (into out next))))\n           (dedupe [1 1 2 3 3 3])",out:"[1 2 3]"},{name:"set get",code:"[($globals.time_offset 5.5) $globals.time_offset]",out:"[5.5 5.5]"},{name:"exe",code:"(test.function 123)",out:"123\nnull"},{name:"Empty parens",code:"()",err:["Parse"]},{name:"Imbalanced parens 1",code:'(print ("hello!")',err:["Parse"]},{name:"Imbalanced parens 2",code:'print "hello!")',err:["Parse"]},{name:"Imbalanced quotes 1",code:'(print "Hello)',err:["Parse","Parse"]},{name:"Imbalanced quotes 2",code:'print "Hello")',err:["Parse"]},{name:"Function as op",code:"(function)",err:["Parse"]},{name:"Function without body",code:"(function func)",err:["Parse"]}];t.doTests=async function(e,t=!0){const r=[];for(let t=0;t<(0,n.len)(i);++t){const{name:c,code:u,err:l,out:p}=i[t],m={dict:new Map,output:""},d={funcs:{},vars:{},lets:[]},f=(0,n.getTimeMs)(),y=await e({get:e=>s(m,e),set:(e,t)=>a(m,e,t),exe:(e,t)=>o(m,e,t),env:d,loopBudget:1e4,rangeBudget:1e3,callBudget:1e3,recurBudget:1e4},u,"testing",!0),v=(l||[]).join()===y.map((({e})=>e)).join(),x=!p||(0,n.trim)(m.output)===p,h=(0,n.getTimeMs)()-f,[b,g,A,C]=[(0,n.padEnd)(`${t+1}`,3),(0,n.padEnd)(c,24),(0,n.padEnd)(`${h}ms`,6),v||y.map((({e,m:t,errCtx:{line:r,col:n}})=>`${e} ${r}:${n}: ${t}`))];r.push({okErr:v,okOut:x,elapsedMs:h,display:`${b} ${g} ${A} ${x} ${C}`})}const c=r.reduce(((e,{elapsedMs:t})=>e+t),0),u=(0,n.len)(r.filter((({okOut:e,okErr:t})=>e&&t)));return(0,n.concat)(r.filter((e=>!t||!e.okOut||!e.okErr)).map((e=>e.display)),[`----- ${u}/${(0,n.len)(r)} tests passed in ${c}ms.`])}},699:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.assertUnreachable=t.typeNames=t.ops=void 0,t.ops={print:{},"print-str":{},"execute-last":{},"!":{exactArity:1},"=":{minArity:2},"!=":{minArity:2},"+":{minArity:2,onlyNum:!0},"-":{minArity:1,onlyNum:!0},"*":{minArity:2,onlyNum:!0},"/":{minArity:2,onlyNum:!0},"//":{minArity:2,onlyNum:!0},"**":{minArity:1,onlyNum:!0},"<":{minArity:2,onlyNum:!0},">":{minArity:2,onlyNum:!0},"<=":{minArity:2,onlyNum:!0},">=":{minArity:2,onlyNum:!0},inc:{exactArity:1,onlyNum:!0},dec:{exactArity:1,onlyNum:!0},min:{minArity:2,onlyNum:!0},max:{minArity:2,onlyNum:!0},abs:{exactArity:1,onlyNum:!0},pi:{exactArity:0},sqrt:{exactArity:1,onlyNum:!0},round:{exactArity:1,onlyNum:!0},floor:{exactArity:1,onlyNum:!0},ceil:{exactArity:1,onlyNum:!0},"odd?":{exactArity:1,onlyNum:!0},"even?":{exactArity:1,onlyNum:!0},"pos?":{exactArity:1,onlyNum:!0},"neg?":{exactArity:1,onlyNum:!0},"zero?":{exactArity:1,onlyNum:!0},"null?":{exactArity:1},"num?":{exactArity:1},"bool?":{exactArity:1},"str?":{exactArity:1},"vec?":{exactArity:1},"dict?":{exactArity:1},"key?":{exactArity:1},"func?":{exactArity:1},rem:{minArity:2,onlyNum:!0},sin:{exactArity:1,onlyNum:!0},cos:{exactArity:1,onlyNum:!0},tan:{exactArity:1,onlyNum:!0},vec:{},dict:{},len:{exactArity:1,types:[["str","vec","dict"]]},num:{exactArity:1,types:[["str","num"]]},"has?":{exactArity:2,types:["str","str"]},idx:{exactArity:2,types:[["str","vec"]]},map:{minArity:2},for:{minArity:2},reduce:{minArity:2,maxArity:3},filter:{exactArity:2},str:{},rand:{maxArity:2,onlyNum:!0},"rand-int":{maxArity:2,onlyNum:!0},while:{},"..":{minArity:2},into:{exactArity:2,types:[["vec","dict"],["vec","dict"]]},push:{minArity:2,maxArity:3,types:[["vec","dict"]]},sect:{minArity:1,maxArity:3,types:[["vec","str"],"num","num"]},reverse:{exactArity:1,types:[["vec","str"]]},sort:{minArity:1,maxArity:2,types:["vec"]},keys:{exactArity:1,types:["dict"]},vals:{exactArity:1,types:["dict"]},do:{minArity:1},val:{minArity:1},range:{minArity:1,maxArity:3,types:["num","num","num"]},"empty?":{exactArity:1,types:[["str","vec","dict"]]},split:{minArity:1,maxArity:2,types:["str","str"]},join:{minArity:1,maxArity:2,types:["vec","str"]},"starts-with?":{exactArity:2,types:["str","str"]},"ends-with?":{exactArity:2,types:["str","str"]},"lower-case":{exactArity:1,types:["str"]},"upper-case":{exactArity:1,types:["str"]},time:{exactArity:0},version:{exactArity:0},tests:{minArity:0,maxArity:1,types:["bool"]},eval:{exactArity:1,types:["str"]}},t.typeNames={null:"null",str:"string",num:"number",bool:"boolean",key:"keyword",ref:"reference",vec:"vector",dict:"dictionary",func:"function"},t.assertUnreachable=e=>0}},t={},r=function r(n){var s=t[n];if(void 0!==s)return s.exports;var a=t[n]={exports:{}};return e[n](a,a.exports,r),a.exports}(669);window.insitux=r.invoker})();