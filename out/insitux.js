(()=>{"use strict";var e={607:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.symbols=t.invoke=t.exeFunc=t.visBoo=t.visKey=t.visFun=t.visDic=t.visVec=t.visNum=t.visStr=t.insituxVersion=void 0,t.insituxVersion=20210914;const n=r(306),s=r(17),{abs:a,cos:o,sin:i,tan:c,pi:u,sign:l,sqrt:m,floor:p,ceil:d,round:f,max:y,min:v}=s,{logn:x,log2:h,log10:g}=s,{concat:b,has:A,flat:C,push:k,reverse:w,slice:N,splice:$,sortBy:B}=s,{ends:E,slen:M,starts:I,sub:P,subIdx:j,substr:H,upperCase:S,lowerCase:q}=s,{trim:D,trimStart:O,trimEnd:T}=s,{getTimeMs:_,randInt:F,randNum:U}=s,{isArray:V,isNum:K,len:R,objKeys:L,range:W,toNum:Z}=s,z=r(127),G=r(699),J=({v:e,t})=>{switch(t){case"bool":case"num":return`${e}`;case"str":case"key":case"ref":return e;case"vec":return`[${e.map((e=>J(e))).join(" ")}]`;case"dict":{const{keys:t,vals:r}=e,[n,s]=[t.map(J),r.map(J)];return`{${n.map(((e,t)=>`${e} ${s[t]}`)).join(", ")}}`}case"null":return"null";case"func":return`<${e}>`}return(0,G.assertUnreachable)(t)};let Q=[];const X=e=>Q.push({t:"bool",v:e}),Y=e=>Q.push({t:"num",v:e}),ee=(e="")=>Q.push({t:"str",v:e}),te=e=>Q.push({t:"key",v:e}),re=(e=[])=>Q.push({t:"vec",v:e}),ne=()=>Q.push({t:"null",v:void 0}),se=e=>Q.push({t:"func",v:e}),ae=({v:e})=>e,oe=({v:e})=>e,ie=({v:e})=>e,ce=({v:e})=>e,ue=({t:e,v:t})=>"bool"===e?t:"null"!==e;t.visStr=e=>"str"===e.t,t.visNum=e=>"num"===e.t,t.visVec=e=>"vec"===e.t,t.visDic=e=>"dict"===e.t,t.visFun=e=>"func"===e.t,t.visKey=e=>"key"===e.t,t.visBoo=e=>"bool"==e.t;const le=({t:e,v:t})=>"vec"===e?N(t):"str"===e?[...t].map((e=>({t:"str",v:e}))):"dict"===e?t.keys.map(((e,r)=>({t:"vec",v:[e,t.vals[r]]}))):[],me=e=>e.reduce(((e,t)=>e+J(t)),""),pe=e=>{R(e)%2==1&&e.pop();const t=e.filter(((e,t)=>t%2==0)),r=e.filter(((e,t)=>t%2==1)),n=[],s=[];return t.forEach(((e,t)=>{const a=n.findIndex((t=>ye(t,e)));-1===a?(n.push(e),s.push(r[t])):s[a]=r[t]})),{t:"dict",v:{keys:n,vals:s}}},de=(e,t)=>({e:"Type",m:e,errCtx:t}),fe=(e,t)=>R(e)===R(t)&&!e.some(((e,r)=>!ye(e,t[r]))),ye=(e,t)=>{const{t:r}=e;switch(r){case"null":return!0;case"bool":return e.v===t.v;case"num":return ae(e)===ae(t);case"vec":return fe(ie(e),ie(t));case"dict":return((e,t)=>{const[r,n]=[ce(e),ce(t)];return R(r.keys)===R(n.keys)&&fe(r.keys,n.keys)})(e,t);case"str":case"ref":case"key":case"func":return oe(e)===oe(t)}return(0,G.assertUnreachable)(r)},ve=({keys:e,vals:t},r)=>{const n=e.findIndex((e=>ye(e,r)));return-1===n?{t:"null",v:void 0}:t[n]},xe=({keys:e,vals:t},r,n)=>{const[s,a]=[N(e),N(t)],o=e.findIndex((e=>ye(e,r)));return-1!==o?a[o]=n:(s.push(r),a.push(n)),{t:"dict",v:{keys:s,vals:a}}};async function he(e,r,n,s){const $=e=>[de(e,s)];{const t=function(e,t,r){const{types:n,exactArity:s,maxArity:a,minArity:o,onlyNum:i}=G.ops[e],c=(t,n)=>[{e:"Arity",m:`${e} needs ${t} argument${1!==n?"s":""}`,errCtx:r}],u=R(t);if(void 0!==s){if(u!==s)return c(`exactly ${s}`,s)}else{if(o&&!a&&u<o)return c(`at least ${o}`,o);if(!o&&a&&u>a)return c(`at most ${a}`,a);if(o&&a&&(u<o||u>a))return c(`between ${o} and ${a}`,a)}if(i){const e=t.findIndex((e=>"num"!==e.t));if(-1===e)return[];const n=G.typeNames[t[e].t];return[de(`numeric arguments only, not ${n}`,r)]}return n?n.map(((e,r)=>{if(r>=u)return!1;const n=t[r].t,s=G.typeNames[n];return V(e)?!A(e,n)&&`argument ${r+1} must be either: ${e.map((e=>G.typeNames[e])).join(", ")}, not ${s}`:e!==n&&`argument ${r+1} must be ${G.typeNames[e]}, not ${s}`})).filter((e=>!!e)).map((e=>de(e,r))):[]}(e,r,s);if(R(t))return t}switch(e){case"execute-last":return await ge(n,r.pop(),s)(r);case"str":return Q.push({t:"str",v:me(r)}),[];case"print":case"print-str":return n.exe(e,[{t:"str",v:me(r)}]),ne(),[];case"vec":return re(r),[];case"dict":return Q.push(pe(r)),[];case"len":return Y("str"===r[0].t?M(oe(r[0])):"vec"===r[0].t?R(ie(r[0])):R(ce(r[0]).keys)),[];case"to-num":return K(r[0].v)?Y(Z(r[0].v)):ne(),[];case"to-key":return te(`:${J(r[0])}`),[];case"!":return X(!ue(r[0])),[];case"=":case"!=":for(let t=1,n=R(r);t<n;++t)if(ye(r[t-1],r[t])!==("="===e))return X(!1),[];return X(!0),[];case"-":return Y(1===R(r)?-ae(r[0]):r.map(ae).reduce(((e,t)=>e-t))),[];case"**":return Y(ae(r[0])**(1===R(r)?2:ae(r[1]))),[];case"+":return Y(r.map(ae).reduce(((e,t)=>e+t))),[];case"*":return Y(r.map(ae).reduce(((e,t)=>e*t))),[];case"/":return Y(r.map(ae).reduce(((e,t)=>e/t))),[];case"//":return Y(r.map(ae).reduce(((e,t)=>p(e/t)))),[];case"rem":return Y(r.map(ae).reduce(((e,t)=>e%t))),[];case"min":return Y(r.map(ae).reduce(((e,t)=>v(e,t)))),[];case"max":return Y(r.map(ae).reduce(((e,t)=>y(e,t)))),[];case"<":case">":case"<=":case">=":for(let t=1,n=R(r);t<n;++t){const[n,s]=[r[t-1].v,r[t].v];if("<"===e&&n>=s||">"===e&&n<=s||"<="===e&&n>s||">="===e&&n<s)return X(!1),[]}return X(!0),[];case"inc":return Y(r[0].v+1),[];case"dec":return Y(r[0].v-1),[];case"abs":return Y(a(ae(r[0]))),[];case"pi":return Y(u),[];case"sin":case"cos":case"tan":case"sqrt":case"round":case"floor":case"ceil":case"logn":case"log2":case"log10":return Y({sin:i,cos:o,tan:c,sqrt:m,round:f,floor:p,ceil:d,logn:x,log2:h,log10:g}[e](ae(r[0]))),[];case"odd?":case"even?":return X(ae(r[0])%2==("odd?"===e?1:0)),[];case"pos?":case"neg?":case"zero?":{const t=ae(r[0]);return X("pos?"===e?t>0:"neg?"===e?t<0:!t),[]}case"null?":case"num?":case"bool?":case"str?":case"dict?":case"vec?":case"key?":case"func?":return X("null?"===e&&"null"===r[0].t||"num?"===e&&"num"===r[0].t||"bool?"===e&&"bool"===r[0].t||"str?"===e&&"str"===r[0].t||"dict?"===e&&"dict"===r[0].t||"vec?"===e&&"vec"===r[0].t||"key?"===e&&"key"===r[0].t||"func?"===e&&"func"===r[0].t),[];case"has?":return X(P(oe(r[0]),oe(r[1]))),[];case"idx":{let e=-1;if("str"===r[0].t){if("str"!==r[1].t)return $("strings can only contain strings");e=j(oe(r[0]),oe(r[1]))}else"vec"===r[0].t&&(e=ie(r[0]).findIndex((e=>ye(e,r[1]))));return-1===e?ne():Y(e),[]}case"map":case"for":case"reduce":case"filter":{const t=ge(n,r.shift(),s),a=e=>"vec"===e||"str"===e||"dict"===e,o="map"===e||"for"===e?r.findIndex((({t:e})=>!a(e))):a(r[0].t)?-1:0;if(-1!==o)return $(`argument 2 must be either: string, vector, dictionary, not ${G.typeNames[r[o].t]}`);if("for"===e){const e=r.map(le),a=e.map(R),o=a.map(((e,t)=>N(a,0,t+1).reduce(((e,t)=>e*t))));o.unshift(1);const i=o.pop();if(i>n.loopBudget)return[{e:"Budget",m:"would exceed loop budget",errCtx:s}];const c=[];for(let r=0;r<i;++r){const n=o.map(((e,t)=>p(r/e%a[t]))),s=await t(e.map(((e,t)=>e[n[t]])));if(R(s))return s;c.push(Q.pop())}return re(c),[]}if("map"===e){const e=r.map(le),n=v(...e.map((e=>R(e)))),s=[];for(let r=0;r<n;++r){const n=await t(e.map((e=>e[r])));if(R(n))return n;s.push(Q.pop())}return re(s),[]}const i=le(r.shift());if("filter"===e){const e=[];for(let r=0,n=R(i);r<n;++r){const n=await t([i[r]]);if(R(n))return n;ue(Q.pop())&&e.push(i[r])}return re(e),[]}if(R(i)<2)return k(Q,i),[];let c=(R(r)?r:i).shift();for(let e=0,r=R(i);e<r;++e){const r=await t([c,i[e]]);if(R(r))return r;c=Q.pop()}Q.push(c)}return[];case"rand-int":case"rand":{const t=R(r),[n,s]=[t<2?0:ae(r[0]),0===t?1+Z("rand-int"===e):ae(1===t?r[0]:r[1])];Y("rand-int"===e?F(n,s):U(n,s))}return[];case"do":case"val":return Q.push("do"===e?r.pop():r.shift()),[];case"..":{const e=ge(n,r.shift(),s);return await e(C(r.map((e=>"vec"===e.t?ie(e):[e]))))}case"into":{const e="vec"===r[0].t,t="vec"===r[1].t;if(e)re(b(ie(r[0]),t?ie(r[1]):le(r[1])));else if(t){const e=le(r[1]);Q.push(pe(b(C(le(r[0]).map(ie)),e)))}else{const{keys:e,vals:t}=ce(r[0]),n=ce(r[1]);L={keys:b(e,n.keys),vals:b(t,n.vals)},Q.push({t:"dict",v:L})}return[]}case"push":if("vec"===r[0].t)re(b(le(r[0]),[r[1]]));else{if(R(r)<3)return[{e:"Arity",m:"key and value both required",errCtx:s}];Q.push(xe(ce(r[0]),r[1],r[2]))}return[];case"sect":{const e=r[0],t="vec"===e.t,n=t?R(ie(e)):M(oe(e));let s=0,a=n;switch(R(r)){case 1:s=1;break;case 2:{const e=ae(r[1]);e<0?a+=e:s+=e;break}case 3:{const e=ae(r[1]),t=ae(r[2]);s=e<0?n+e+(t<0?t:0):s+e,a=(t<0?a:s)+t;break}}return s=y(s,0),a=v(a,n),s>a?((t?re:ee)(),[]):(t?re(N(ie(e),s,a)):ee(H(oe(r[0]),s,a-s)),[])}case"reverse":return"str"===r[0].t?ee(me(w(le(r[0])))):re(w(le(r[0]))),[];case"sort":{if(!R(ie(r[0])))return re(),[];const e=le(r[0]),a=[];if(1===R(r))k(a,e.map((e=>[e,e])));else{const t=ge(n,r.pop(),s);for(let r=0,n=R(e);r<n;++r){const n=await t([e[r]]);if(R(n))return n;a.push([e[r],Q.pop()])}}const o=a[0][1].t;return a.some((([e,{t}])=>t!==o||!A(["num","str"],t)))?$("can only sort by all number or all string"):((0,t.visNum)(a[0][1])?B(a,(([e,t],[r,n])=>ae(t)>ae(n)?1:-1)):B(a,(([e,t],[r,n])=>oe(t)>oe(n)?1:-1)),re(a.map((([e])=>e))),[])}case"range":{const[e,t,o]=r.map(ae),i=o&&o<0&&e<t,[c,u]=R(r)>1?i?[t-1,e-1]:[e,t]:[0,e],m=l((u-c)*(o||1))*(o||1),p=d(a((u-c)/m));if(!p)return re([]),[];if(p>n.rangeBudget)return[{e:"Budget",m:"range budget depleted",errCtx:s}];n.rangeBudget-=p;const f=W(p).map((e=>e*m+c));return re(f.map((e=>({t:"num",v:e})))),[]}case"empty?":return X(!R(le(r[0]))),[];case"keys":case"vals":return re(ce(r[0])["keys"===e?"keys":"vals"]),[];case"split":return re(oe(r[0]).split(R(r)>1?oe(r[1]):" ").map((e=>({t:"str",v:e})))),[];case"join":return ee(ie(r[0]).map(J).join(R(r)>1?oe(r[1]):" ")),[];case"starts-with?":return X(I(oe(r[0]),oe(r[1]))),[];case"ends-with?":return X(E(oe(r[0]),oe(r[1]))),[];case"upper-case":case"lower-case":case"trim":case"trim-start":case"trim-end":return ee(("upper-case"===e?S:"lower-case"===e?q:"trim"===e?D:"trim-start"===e?O:T)(oe(r[0]))),[];case"time":return Y(_()),[];case"version":return Y(t.insituxVersion),[];case"tests":{const e=await(0,z.doTests)(Ce,!(R(r)&&ue(r[0]))),t=e.pop();for(const t of e)await he("print",[{v:t,t:"str"}],n,s);ee(t)}return[];case"eval":{delete n.env.funcs.entry;const e=R(Q),t=await Ae(n,oe(r[0]),s.invocationId);return R(t)?[{e:"Eval",m:"error within evaluated code",errCtx:s}]:(e===R(Q)&&ne(),[])}}var L;return[{e:"Unexpected",m:"operation doesn't exist",errCtx:s}]}function ge(e,r,n){const s=[{e:"Arity",m:"one argument required",errCtx:n}];if((0,t.visStr)(r)||(0,t.visFun)(r)){const t=r.v;return G.ops[t]?r=>he(t,r,e,n):t in e.env.funcs?r=>be(e,e.env.funcs[t],r):t in e.env.vars?ge(e,e.env.vars[t],n):t in e.env.lets[R(e.env.lets)-1]?ge(e,e.env.lets[R(e.env.lets)-1][t],n):I(t,"$")?async r=>{if(!R(r))return s;const a=await e.set(H(t,1),r[0]);return Q.push(r[0]),a?[{e:"External",m:a,errCtx:n}]:[]}:async r=>{const{err:s,value:a}=await e.exe(t,r);return s||Q.push(a),s?[{e:"External",m:s,errCtx:n}]:[]}}if((0,t.visKey)(r))return async e=>{if(!R(e))return s;if("dict"!==e[0].t){const t=G.typeNames[e[0].t];return[de(`argument 1 must be dictionary, not ${t}`,n)]}return Q.push(ve(ce(e[0]),r)),[]};if((0,t.visNum)(r)){const e=r.v;return async t=>{if(!R(t))return s;const r=t[0];if("str"!==r.t&&"vec"!==r.t&&"dict"!==r.t){const e=G.typeNames[r.t];return[de(`argument must be string, vector, or dictionary, not ${e}`,n)]}const o=le(r);return a(e)>=R(o)?ne():e<0?Q.push(o[R(o)+e]):Q.push(o[e]),[]}}if((0,t.visVec)(r)){const{v:e}=r;return async t=>{if(!R(t))return s;const r=e.find((e=>ye(e,t[0])));return r?Q.push(r):ne(),[]}}if((0,t.visDic)(r)){const e=r.v;return async t=>{if(1===R(t))Q.push(ve(e,t[0]));else{if(2!==R(t))return[{e:"Arity",m:"dict as operation takes one or two arguments only",errCtx:n}];Q.push(xe(e,t[0],t[1]))}return[]}}if((0,t.visBoo)(r)){const e=r.v;return async t=>!R(t)||R(t)>2?[{e:"Arity",m:"boolean as operation takes one or two arguments only",errCtx:n}]:(Q.push(e?t[0]:R(t)>1?t[1]:{t:"null",v:void 0}),[])}return async e=>[{e:"Operation",m:`${J(r)} is an invalid operation`,errCtx:n}]}async function be(e,r,n){--e.callBudget,e.env.lets.push({});for(let s=0,a=R(r.ins);s<a;++s){const{typ:o,value:i,errCtx:c}=r.ins[s],u=e.loopBudget<1;if(u||e.callBudget<1)return[{e:"Budget",m:(u?"looped":"called")+" too many times",errCtx:c}];switch(o){case"nul":ne();break;case"boo":X(i);break;case"num":Y(i);break;case"str":ee(i);break;case"key":te(i);break;case"var":e.env.vars[i]=Q[R(Q)-1];break;case"let":e.env.lets[R(e.env.lets)-1][i]=Q[R(Q)-1];break;case"par":{const e=i;-1===e?re(n):R(n)<=e?ne():Q.push(n[e])}break;case"ref":{const t=i;if(G.ops[t])se(t);else if(I(t,"$")){const{value:r,err:n}=await e.get(H(t,1));if(n)return[{e:"External",m:n,errCtx:c}];Q.push(r)}else if(t in e.env.vars)Q.push(e.env.vars[t]);else if(t in e.env.lets[R(e.env.lets)-1])Q.push(e.env.lets[R(e.env.lets)-1][t]);else{if(!(t in e.env.funcs))return[{e:"Reference",m:`"${t}" did not exist`,errCtx:c}];se(t)}}break;case"op":case"exe":{let[o,u]=i;const l=$(Q,R(Q)-u,u);if(R(l)!==u)return[{e:"Unexpected",m:`${o} stack depleted`,errCtx:c}];if(s===a-1&&(0,t.visStr)(o)&&o.v===r.name){if(e.env.lets[R(e.env.lets)-1]={},s=-1,n=l,--e.recurBudget,!e.recurBudget)return[{e:"Budget",m:"recurred too many times",errCtx:c}];continue}const m=ge(e,o,c),p=await m(l);if(R(p))return p}break;case"or":ue(Q[R(Q)-1])?s+=i:Q.pop();break;case"if":ue(Q.pop())||(s+=i);break;case"jmp":s+=i;break;case"loo":s+=i,--e.loopBudget;break;case"pop":$(Q,R(Q)-i,i);break;case"ret":i?$(Q,0,R(Q)-1):ne(),s=a;break;default:(0,G.assertUnreachable)(o)}}return e.env.lets.pop(),[]}async function Ae(e,t,r){const s=(0,n.parse)(t,r);return R(s.errors)?s.errors:(e.env.funcs={...e.env.funcs,...s.funcs},"entry"in e.env.funcs?await be(e,e.env.funcs.entry,[]):[])}async function Ce(e,t,r,n=!1){const{callBudget:s,loopBudget:a,recurBudget:o,rangeBudget:i}=e,c=await Ae(e,t,r);return e.env.lets=[],e.callBudget=s,e.recurBudget=o,e.loopBudget=a,e.rangeBudget=i,delete e.env.funcs.entry,!R(c)&&n&&R(Q)&&await e.exe("print",[{t:"str",v:J(Q[R(Q)-1])}]),Q=[],c}t.exeFunc=be,t.invoke=Ce,t.symbols=function(e){let t=["function"];return t=b(t,L(G.ops).filter((e=>"execute-last"!==e))),t=b(t,L(e.env.funcs)),t=b(t,L(e.env.vars)),t}},669:(e,t,r)=>{t.invoker=t.Z=void 0;const n=r(607),s=r(17),a=new Map;t.Z=/[\[\]\(\) ]/,t.invoker=async function(e,r){const o=(0,s.getTimeMs)().toString();a.set(o,r);const i=await(0,n.invoke)(e,r,o,!0);let c=[];return i.forEach((({e,m:r,errCtx:{line:n,col:o,invocationId:i}})=>{const u=a.get(i).split("\n")[n-1],l=(0,s.substr)(u,o-1).split(t.Z)[0],m=(0,s.trimStart)((0,s.substr)(u,0,o-1));if(c.push({type:"message",text:(0,s.padEnd)(`${n}`,4)+m}),l){const e=(0,s.substr)(u,o-1+l.length);c.push({type:"error",text:l}),c.push({type:"message",text:`${e}\n`})}else{const e=(0,s.substr)(u,o);c.push({type:"error",text:u[o-1]}),c.push({type:"message",text:`${e}\n`})}c.push({type:"message",text:`${e} Error: ${r}.\n`})})),c}},306:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parse=void 0;const n=r(17),{concat:s,has:a,flat:o,push:i,slice:c}=n,{slen:u,starts:l,sub:m,substr:p,strIdx:d}=n,{isNum:f,len:y,toNum:v}=n,x=r(699),h=r(699);function g(e,t){if(!y(e))return[];const{typ:r,text:n,errCtx:s}=e.shift();switch(r){case"str":return[{typ:"str",value:n,errCtx:s}];case"num":return[{typ:"num",value:v(n),errCtx:s}];case"sym":if("true"===n||"false"===n)return[{typ:"boo",value:"true"===n,errCtx:s}];if("null"===n)return[{typ:"nul",value:void 0,errCtx:s}];if(l(n,":"))return[{typ:"key",value:n,errCtx:s}];if(l(n,"#")&&f(p(n,1))){const e=v(p(n,1));return e<0?[{typ:"nul",errCtx:s}]:[{typ:"par",value:e,errCtx:s}]}return a(t,n)?[{typ:"par",value:t.indexOf(n),errCtx:s}]:"args"===n?[{typ:"par",value:-1,errCtx:s}]:[{typ:"ref",value:n,errCtx:s}];case"ref":return[{typ:"def",value:n,errCtx:s}];case"(":return function(e,t){const r=e.shift();if(!r)return[];const{typ:n,text:s,errCtx:o}=r;let c=s;const u=e=>[{typ:"err",value:e,errCtx:o}];if("var"===c||"let"===c){const[r,n]=[g(e,t),g(e,t)];return y(r)&&y(n)&&!y(g(e,t))?[...n,{typ:c,value:r[0].value,errCtx:o}]:u("must provide reference name and value only")}if("if"===c||"when"===c){const r=g(e,t);if(!y(r))return u("must provide condition");const n=r;if("if"===c){const r=g(e,t);if(!y(r))return u("must provide a branch");n.push({typ:"if",value:y(r)+1,errCtx:o}),i(n,r);const s=g(e,t);if(y(s)){if(n.push({typ:"jmp",value:y(s),errCtx:o}),i(n,s),y(g(e,t)))return u("too many branches")}else n.push({typ:"jmp",value:1,errCtx:o}),n.push({typ:"nul",value:void 0,errCtx:o})}else{const r=[];for(;;){const n=g(e,t);if(!y(n))break;i(r,n)}n.push({typ:"if",value:y(r)+1,errCtx:o}),i(n,r),n.push({typ:"jmp",value:1,errCtx:o}),n.push({typ:"nul",value:void 0,errCtx:o})}return n}if("and"===c||"or"===c||"while"===c){const r=[];let n=0;for(;;){const s=g(e,t);if(!y(s))break;r.push(s),n+=y(s)}if(y(r)<2)return u("requires at least two arguments");const s=[];if("while"===c){n+=2;const e=r.shift();return i(s,e),s.push({typ:"if",value:n-y(e),errCtx:o}),r.forEach((e=>i(s,e))),s.push({typ:"pop",value:y(r),errCtx:o}),s.push({typ:"loo",value:-(n+1),errCtx:o}),s}n+=y(r),n+=v("and"===c);const a="and"===c?"if":"or";for(let e=0;e<y(r);++e)i(s,r[e]),n-=y(r[e]),s.push({typ:a,value:n,errCtx:o}),--n;return"and"===c?i(s,[{typ:"boo",value:!0,errCtx:o},{typ:"jmp",value:1,errCtx:o},{typ:"boo",value:!1,errCtx:o}]):s.push({typ:"boo",value:!1,errCtx:o}),s}const m=[];let p=0;if("("===n||a(t,s)||l(s,"#")){e.unshift(r);const n=g(e,t);i(m,n),c="execute-last",++p}const d=[];for(;y(e);){const r=g(e,t);if(!y(r))break;++p,i(d,r)}return"return"===c?[...d,{typ:"ret",value:!!y(d),errCtx:o}]:(m.push({typ:x.ops[c]?"op":"exe",value:["num"===n?{t:"num",v:v(c)}:l(c,":")?{t:"key",v:c}:x.ops[c]?{t:"func",v:c}:"true"===c||"false"===c?{t:"bool",v:"true"===c}:{t:"str",v:c},p],errCtx:o}),[...d,...m])}(e,t);case")":return[];default:return(0,h.assertUnreachable)(r)}}t.parse=function(e,t){const{tokens:r,stringError:n}=function(e,t){const r=[];let n=!1,s=!1,a=[0,0],o=!1,i=!1,c=!1,l=1,p=0;for(let f=0,v=u(e);f<v;++f){const u=d(e,f),x=f+1!==v?d(e,f+1):"";if(++p,c){"\n"===u&&(c=!1,++l,p=0);continue}if(s){s=!1,n&&(r[y(r)-1].text+={n:"\n",t:"\t",'"':'"'}[u]||`\\${u}`);continue}if("\\"===u){s=!0;continue}if('"'===u){(n=!n)&&(a=[l,p],r.push({typ:"str",text:"",errCtx:{invocationId:t,line:l,col:p}})),i=o=!1;continue}const h=m(" \t\n\r",u);if(!n&&h){i=o=!1,"\n"===u&&(++l,p=0);continue}if(!n&&";"===u){c=!0;continue}const g={invocationId:t,line:l,col:p},b=e=>m("0123456789",e),A=m("()[]{}",u);if(i&&!b(u)&&(i="."===u&&!m(r[y(r)-1].text,"."),i||A||h||(o=!0,r[y(r)-1].typ="sym")),o&&A&&(o=!1),!n&&!o&&!i){if(A){const e={"[":"(","{":"(","(":"(",")":")","}":")","]":")"}[u];r.push({typ:e,text:e,errCtx:g}),"["===u?r.push({typ:"sym",text:"vec",errCtx:g}):"{"===u&&r.push({typ:"sym",text:"dict",errCtx:g});continue}i=b(u)||"."===u&&b(x)||"-"===u&&(b(x)||"."===x),o=!i;let e=o?"sym":"num";if(y(r)){const{typ:t,text:n}=r[y(r)-1];"sym"!==t||"var"!==n&&"let"!==n||(e="ref")}r.push({typ:e,text:"",errCtx:g})}r[y(r)-1].text+=u}return{tokens:r,stringError:n?a:void 0}}(e,t),a=function(e,t,r){const n=[],s=(e,t)=>n.push({e:"Parse",m:e,errCtx:t}),a=e=>y(t.filter((({typ:t})=>t===e))),[o,i]=[a("("),a(")")];{const[e,n]=function(e,t,r){const n=r>=t,[s,a]=[n?"(":")",n?")":"("],o=n?1:-1;for(let t=y(e),r=n?0:t-1,i=0;n?r<t:r>=0;r+=o){const{typ:t,errCtx:{line:n,col:o}}=e[r];if(i+=v(t===s)-v(t===a),i<0)return[n,o]}return[0,0]}(t,o,i);e+n&&s("unmatched parenthesis",{invocationId:r,line:e,col:n})}if(e){const[t,n]=e;s("unmatched double quotation marks",{invocationId:r,line:t,col:n})}let c;for(let e=0,r=!1;e<y(t);++e){if(r&&")"===t[e].typ){c=t[e];break}r="("===t[e].typ}return c&&s("empty expression forbidden",c.errCtx),n}(n,r,t);if(y(a))return{errors:a,funcs:{}};const l=function(e){const t=e=>y(e)>1&&"sym"===e[1].typ&&"function"===e[1].text,r=e.filter((e=>t(e))),n=o(e.filter((e=>!t(e)))),a=r.map((e=>({name:e[2].text,tokens:c(e,3),errCtx:e[2].errCtx})));return y(n)?s(a,[{name:"entry",tokens:n,errCtx:n[0].errCtx}]):a}(function(e){const t=[[]];let r=0;return e.forEach((e=>{t[y(t)-1].push(e),r+=v("("===e.typ)-v(")"===e.typ),0===r&&t.push([])})),t}(r)).map((e=>function({name:e,tokens:t},r){const[n,s]=function(e,t){const r=[],n=[];for(let t=0,s=!1;t<y(e);++t)s||(s="sym"!==e[t].typ),(s?n:r).push(e[t]);return[r,n]}(t);if(!y(n)&&!y(s))return{err:{e:"Parse",m:"empty function body",errCtx:r}};if(y(s)&&")"===s[0].typ){if(!y(n))return{err:{e:"Parse",m:"empty function body",errCtx:r}};s.unshift(n.pop())}y(n)&&!y(s)&&s.push(n.pop());const a=[];for(;y(s);)i(a,g(s,n.map((e=>e.text))));const o=a.filter((e=>"err"===e.typ));return y(o)?{err:{e:"Parse",m:o[0].value,errCtx:o[0].errCtx}}:{func:{name:e,ins:a}}}(e,{invocationId:t,line:e.errCtx.line,col:e.errCtx.col}))),[p,f]=function(e,t){const r=[],n=[];return e.forEach((e=>{return(t=e,t.err?n:r).push(e);var t})),[r,n]}(l);i(a,f.map((e=>e.err)));const x={};return p.forEach((({func:e})=>x[e.name]=e)),{errors:a,funcs:x}}},17:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.log10=t.log2=t.logn=t.pi=t.sign=t.ceil=t.floor=t.round=t.sqrt=t.tan=t.cos=t.sin=t.max=t.min=t.abs=t.getTimeMs=t.objKeys=t.range=t.randInt=t.randNum=t.padEnd=t.trimEnd=t.trimStart=t.trim=t.upperCase=t.lowerCase=t.reverse=t.sortBy=t.push=t.concat=t.flat=t.ends=t.starts=t.has=t.subIdx=t.sub=t.strIdx=t.substr=t.isArray=t.isNum=t.slen=t.len=t.splice=t.slice=t.toNum=void 0,t.toNum=e=>Number(e),t.slice=(e,t,r)=>e.slice(t,r),t.splice=(e,t,r)=>e.splice(t,r),t.len=e=>e.length,t.slen=e=>e.length,t.isNum=e=>!Number.isNaN(Number(e)),t.isArray=e=>Array.isArray(e),t.substr=(e,t,r)=>e.substring(t,t+(r??e.length)),t.strIdx=(e,t)=>e[t],t.sub=(e,t)=>e.includes(t),t.subIdx=(e,t)=>e.indexOf(t),t.has=(e,t)=>e.includes(t),t.starts=(e,t)=>e.startsWith(t),t.ends=(e,t)=>e.endsWith(t),t.flat=e=>e.flat(),t.concat=(e,t)=>e.concat(t),t.push=(e,t)=>e.push(...t),t.sortBy=(e,t)=>e.sort(t),t.reverse=e=>e.reverse(),t.lowerCase=e=>e.toLowerCase(),t.upperCase=e=>e.toUpperCase(),t.trim=e=>e.trim(),t.trimStart=e=>e.trimStart(),t.trimEnd=e=>e.trimEnd(),t.padEnd=(e,t)=>e.padEnd(t),t.randNum=(e,t)=>e+Math.random()*(t-e),t.randInt=(e,r)=>Math.floor((0,t.randNum)(e,r)),t.range=e=>[...Array(e).keys()],t.objKeys=e=>Object.keys(e),t.getTimeMs=()=>(new Date).getTime(),t.abs=Math.abs,t.min=Math.min,t.max=Math.max,t.sin=Math.sin,t.cos=Math.cos,t.tan=Math.tan,t.sqrt=Math.sqrt,t.round=Math.round,t.floor=Math.floor,t.ceil=Math.ceil,t.sign=Math.sign,t.pi=Math.PI,t.logn=Math.log,t.log2=Math.log2,t.log10=Math.log10},127:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.doTests=void 0;const n=r(17);async function s(e,t){return e.dict.has(t)?{value:e.dict.get(t),err:void 0}:{value:{t:"null",v:void 0},err:`"${t} not found.`}}async function a(e,t,r){e.dict.set(t,r)}async function o(e,t,r){const n={t:"null",v:void 0};switch(t){case"print-str":e.output+=r[0].v;break;case"print":case"test.function":e.output+=r[0].v+"\n";break;default:return{value:n,err:"operation does not exist"}}return{value:n,err:void 0}}const i=[{name:"Hello, world!",code:'"Hello, world!"',out:"Hello, world!"},{name:"Say Hello, world!",code:'(print "Hello, world!")',out:"Hello, world!\nnull"},{name:"1 + 1 = 2",code:"(+ 1 1)",out:"2"},{name:"Negate 1 = -1",code:"(- 1)",out:"-1"},{name:"(1+1)+1+(1+1) = 5",code:"(+ (+ 1 1) 1 (+ 1 1))",out:"5"},{name:"Conditional head",code:"((if true + -) 12 9 1)",out:"22"},{name:"Whens",code:'[(when 123 (print "hi") 234) (when false (print "bye"))]',out:"hi\n[234 null]"},{name:"Cond number head",code:"((if false 1 2) [:a :b :c])",out:":c"},{name:"and & short-circuit",code:"[(and true (if true null 1) true) (and 1 2 3)]",out:"[false true]"},{name:"or & short-circuit",code:'[(or true (print "hello") 1) (or false (print-str "-> ") 1)]',out:"-> [true 1]"},{name:"String retrieve",code:'(2 "Hello")',out:"l"},{name:"Vector retrieve",code:"(2 [:a :b :c :d])",out:":c"},{name:"Key as operation",code:'(:age {:name "Patrick" :age 24})',out:"24"},{name:"Dictionary as op 1",code:'({"name" "Patrick" "age" 24} "age")',out:"24"},{name:"Dictionary as op 2",code:'({"name" "Patrick"} "age" 24)',out:"{name Patrick, age 24}"},{name:"Equalities",code:'[(= 1 2 1)\n            (!= 1 2 1)\n            (= "Hello" "hello")\n            (!= "world" "world")\n            (= [0 [1]] [0 [1]])]',out:"[false true false false true]"},{name:"Define and retrieve",code:"(var a 1) a",out:"1"},{name:"Define and add",code:"(var a 1) (inc a)",out:"2"},{name:"Define op and call",code:"(var f +) (f 2 2)",out:"4"},{name:"Define vec and call",code:"(var f [1]) (f 1)",out:"1"},{name:"Define num and call",code:"(var f 1) (f [:a :b :c])",out:":b"},{name:"Print simple vector",code:"[1 2 3]",out:"[1 2 3]"},{name:"Boolean select",code:"[(true 1 2) (false 1)]",out:"[1 null]"},{name:"Sum vector of numbers",code:"[(reduce + [1 2 3]) (reduce + [1 2 3] 3)]",out:"[6 9]"},{name:"Sum vectors of numbers",code:"(map + [1 2 3] [1 2 3 4])",out:"[2 4 6]"},{name:"Filter by integer",code:'(filter 2 [[1] [:a :b :c] "hello" "hi"])',out:"[[:a :b :c] hello]"},{name:"Comments, short decimal",code:';((print "Hello")\n           .456',out:"0.456"},{name:"Dictionary into vector",code:"(into [1 2] {3 4 5 6})",out:"[1 2 [3 4] [5 6]]"},{name:"Vector into dictionary",code:"(into {[0] 1 [2] 3} [[0] 2])",out:"{[0] 2, [2] 3}"},{name:"While loop",code:"(var n 5)\n           (while (< 0 n)\n             (print-str n)\n             (var n (dec n)))",out:"543215"},{name:"Define with no call",code:'(function func (print "Nothing."))'},{name:"Call greet func",code:'(function greeting (print "Hello!")) (greeting)',out:"Hello!\nnull"},{name:"Call const value func",code:"(function const 123) (const)",out:"123"},{name:"Call identity funcs",code:"(function id1 #)\n           (function id2 x x)\n           [(id1 123) (id2 456)]",out:"[123 456]"},{name:"Call greet with name",code:'(function greeting name (print "Hello, " name "!"))\n           (greeting "Patrick")',out:"Hello, Patrick!\nnull"},{name:"Call with too few args",code:"(function func a b c [a b c]) (func 1 2)",out:"[1 2 null]"},{name:"Define func and call",code:"(function func a b (+ a b)) (var f func) (f 2 2)",out:"4"},{name:"Anonymous parameters",code:"(function avg<n? (< (/ (.. + #) (len #)) #1))\n           (avg<n? [0 10 20 30 40] 5)",out:"false"},{name:"Call parameter",code:'(function f x (x "hello")) (f print)',out:"hello\nnull"},{name:"Let and retrieve",code:"(function f (let a 1) a) (f)",out:"1"},{name:"Let num op and call",code:"(function f (let n 0) (n [0])) (f)",out:"0"},{name:"Explicit return",code:"(function f (return 123) (print 456)) (f)",out:"123"},{name:"String instead of number",code:'(function sum (.. + args))\n           (print (sum 2 2))\n           (sum 2 "hi")',out:"4",err:["Type"]},{name:"Reference non-existing",code:"x",err:["Reference"]},{name:"Expired let retrieve",code:"(function f (let a 1) a) (f) a",err:["Reference"]},{name:"Call non-existing",code:"(x)",err:["External"]},{name:"Call budget",code:"(function f (f)) (f)",err:["Budget"]},{name:"Loop budget",code:"(var n 10000)\n           (while (< 0 n)\n             (var n (dec n)))",err:["Budget"]},{name:"Range budget",code:"(range 10000)",err:["Budget"]},{name:"Fibonacci 13",code:"(function fib n\n             (if (< n 2) n\n               (+ (fib (dec n))\n                  (fib (- n 2)))))\n           (fib 13)",out:"233"},{name:"dedupe (tail-call optim)",code:"(function dedupe list -out\n             (let out (or -out []))\n             (let next (if (out (0 list)) [] [(0 list)]))\n             (if (empty? list) out\n                 (dedupe (sect list) (into out next))))\n           (dedupe [1 1 2 3 3 3])",out:"[1 2 3]"},{name:"set get",code:"[($globals.time_offset 5.5) $globals.time_offset]",out:"[5.5 5.5]"},{name:"exe",code:"(test.function 123)",out:"123\nnull"},{name:"Empty parens",code:"()",err:["Parse"]},{name:"Imbalanced parens 1",code:'(print ("hello!")',err:["Parse"]},{name:"Imbalanced parens 2",code:'print "hello!")',err:["Parse"]},{name:"Imbalanced quotes 1",code:'(print "Hello)',err:["Parse","Parse"]},{name:"Imbalanced quotes 2",code:'print "Hello")',err:["Parse"]},{name:"Function as op",code:"(function)",err:["Parse"]},{name:"Function without body",code:"(function func)",err:["Parse"]}];t.doTests=async function(e,t=!0){const r=[];for(let t=0;t<(0,n.len)(i);++t){const{name:c,code:u,err:l,out:m}=i[t],p={dict:new Map,output:""},d={funcs:{},vars:{},lets:[]},f=(0,n.getTimeMs)(),y=await e({get:e=>s(p,e),set:(e,t)=>a(p,e,t),exe:(e,t)=>o(p,e,t),env:d,loopBudget:1e4,rangeBudget:1e3,callBudget:1e3,recurBudget:1e4},u,"testing",!0),v=(l||[]).join()===y.map((({e})=>e)).join(),x=!m||(0,n.trim)(p.output)===m,h=(0,n.getTimeMs)()-f,[g,b,A,C]=[(0,n.padEnd)(`${t+1}`,3),(0,n.padEnd)(c,24),(0,n.padEnd)(`${h}ms`,6),v||y.map((({e,m:t,errCtx:{line:r,col:n}})=>`${e} ${r}:${n}: ${t}`))];r.push({okErr:v,okOut:x,elapsedMs:h,display:`${g} ${b} ${A} ${x} ${C}`})}const c=r.reduce(((e,{elapsedMs:t})=>e+t),0),u=(0,n.len)(r.filter((({okOut:e,okErr:t})=>e&&t)));return(0,n.concat)(r.filter((e=>!t||!e.okOut||!e.okErr)).map((e=>e.display)),[`----- ${u}/${(0,n.len)(r)} tests passed in ${c}ms.`])}},699:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.assertUnreachable=t.typeNames=t.ops=void 0,t.ops={print:{},"print-str":{},"execute-last":{},"!":{exactArity:1},"=":{minArity:2},"!=":{minArity:2},"+":{minArity:2,onlyNum:!0},"-":{minArity:1,onlyNum:!0},"*":{minArity:2,onlyNum:!0},"/":{minArity:2,onlyNum:!0},"//":{minArity:2,onlyNum:!0},"**":{minArity:1,onlyNum:!0},"<":{minArity:2,onlyNum:!0},">":{minArity:2,onlyNum:!0},"<=":{minArity:2,onlyNum:!0},">=":{minArity:2,onlyNum:!0},inc:{exactArity:1,onlyNum:!0},dec:{exactArity:1,onlyNum:!0},min:{minArity:2,onlyNum:!0},max:{minArity:2,onlyNum:!0},abs:{exactArity:1,onlyNum:!0},pi:{exactArity:0},sqrt:{exactArity:1,onlyNum:!0},round:{exactArity:1,onlyNum:!0},floor:{exactArity:1,onlyNum:!0},ceil:{exactArity:1,onlyNum:!0},logn:{exactArity:1,onlyNum:!0},log2:{exactArity:1,onlyNum:!0},log10:{exactArity:1,onlyNum:!0},"odd?":{exactArity:1,onlyNum:!0},"even?":{exactArity:1,onlyNum:!0},"pos?":{exactArity:1,onlyNum:!0},"neg?":{exactArity:1,onlyNum:!0},"zero?":{exactArity:1,onlyNum:!0},"null?":{exactArity:1},"num?":{exactArity:1},"bool?":{exactArity:1},"str?":{exactArity:1},"vec?":{exactArity:1},"dict?":{exactArity:1},"key?":{exactArity:1},"func?":{exactArity:1},rem:{minArity:2,onlyNum:!0},sin:{exactArity:1,onlyNum:!0},cos:{exactArity:1,onlyNum:!0},tan:{exactArity:1,onlyNum:!0},vec:{},dict:{},len:{exactArity:1,types:[["str","vec","dict"]]},"to-num":{exactArity:1,types:[["str","num"]]},"to-key":{exactArity:1,types:[["str","num"]]},"has?":{exactArity:2,types:["str","str"]},idx:{exactArity:2,types:[["str","vec"]]},map:{minArity:2},for:{minArity:2},reduce:{minArity:2,maxArity:3},filter:{exactArity:2},str:{},rand:{maxArity:2,onlyNum:!0},"rand-int":{maxArity:2,onlyNum:!0},while:{},"..":{minArity:2},into:{exactArity:2,types:[["vec","dict"],["vec","dict"]]},push:{minArity:2,maxArity:3,types:[["vec","dict"]]},sect:{minArity:1,maxArity:3,types:[["vec","str"],"num","num"]},reverse:{exactArity:1,types:[["vec","str"]]},sort:{minArity:1,maxArity:2,types:["vec"]},keys:{exactArity:1,types:["dict"]},vals:{exactArity:1,types:["dict"]},do:{minArity:1},val:{minArity:1},range:{minArity:1,maxArity:3,types:["num","num","num"]},"empty?":{exactArity:1,types:[["str","vec","dict"]]},split:{minArity:1,maxArity:2,types:["str","str"]},join:{minArity:1,maxArity:2,types:["vec","str"]},"starts-with?":{exactArity:2,types:["str","str"]},"ends-with?":{exactArity:2,types:["str","str"]},"lower-case":{exactArity:1,types:["str"]},"upper-case":{exactArity:1,types:["str"]},trim:{exactArity:1,types:["str"]},"trim-start":{exactArity:1,types:["str"]},"trim-end":{exactArity:1,types:["str"]},time:{exactArity:0},version:{exactArity:0},tests:{minArity:0,maxArity:1,types:["bool"]},eval:{exactArity:1,types:["str"]}},t.typeNames={null:"null",str:"string",num:"number",bool:"boolean",key:"keyword",ref:"reference",vec:"vector",dict:"dictionary",func:"function"},t.assertUnreachable=e=>0}},t={},r=function r(n){var s=t[n];if(void 0!==s)return s.exports;var a=t[n]={exports:{}};return e[n](a,a.exports,r),a.exports}(669);window.insitux=r.invoker})();
//# sourceMappingURL=insitux.js.map