(()=>{"use strict";var e={607:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.symbols=t.invoke=t.exeFunc=t.visBoo=t.visKey=t.visFun=t.visDic=t.visVec=t.visNum=t.visStr=t.insituxVersion=void 0,t.insituxVersion=20210912;const n=r(306),s=r(17),{abs:a,cos:o,sin:i,tan:u,pi:c,sign:l,sqrt:m,floor:p,ceil:d,round:f,max:y,min:v}=s,{concat:x,has:h,flat:b,push:g,reverse:A,slice:k,splice:C,sortBy:w}=s,{ends:N,slen:$,starts:B,sub:M,subIdx:E,substr:I}=s,{getTimeMs:P,randInt:j,randNum:H}=s,{isArray:q,isNum:D,len:S,objKeys:O,range:T,toNum:_}=s,F=r(127),V=r(699),K=({v:e,t})=>{switch(t){case"bool":case"num":return`${e}`;case"str":case"key":return e;case"vec":return`[${e.map((e=>K(e))).join(" ")}]`;case"dict":{const{keys:t,vals:r}=e,[n,s]=[t.map(K),r.map(K)];return`{${n.map(((e,t)=>`${e} ${s[t]}`)).join(", ")}}`}case"null":return"null";case"func":return`<${e}>`}return"?"};let R=[];const W=e=>R.push({t:"bool",v:e}),L=e=>R.push({t:"num",v:e}),Z=(e="")=>R.push({t:"str",v:e}),z=(e=[])=>R.push({t:"vec",v:e}),U=e=>R.push({t:"dict",v:e}),G=()=>R.push({t:"null",v:void 0}),J=e=>R.push({t:"func",v:e}),Q=({v:e})=>e,X=({v:e})=>e,Y=({v:e})=>e,ee=({v:e})=>e,te=({t:e,v:t})=>"bool"===e?t:"null"!==e;t.visStr=e=>"str"===e.t,t.visNum=e=>"num"===e.t,t.visVec=e=>"vec"===e.t,t.visDic=e=>"dict"===e.t,t.visFun=e=>"func"===e.t,t.visKey=e=>"key"===e.t,t.visBoo=e=>"bool"==e.t;const re=({t:e,v:t})=>"vec"===e?k(t):"str"===e?[...t].map((e=>({t:"str",v:e}))):"dict"===e?t.keys.map(((e,r)=>({t:"vec",v:[e,t.vals[r]]}))):[],ne=e=>e.reduce(((e,t)=>e+K(t)),""),se=e=>{S(e)%2==1&&e.pop();const t=e.filter(((e,t)=>t%2==0)),r=e.filter(((e,t)=>t%2==1)),n=[],s=[];return t.forEach(((e,t)=>{const a=n.findIndex((t=>ie(t,e)));-1===a?(n.push(e),s.push(r[t])):s[a]=r[t]})),{t:"dict",v:{keys:n,vals:s}}},ae=(e,t)=>({e:"Type",m:e,errCtx:t}),oe=(e,t)=>S(e)===S(t)&&!e.some(((e,r)=>!ie(e,t[r]))),ie=(e,t)=>e.t===t.t&&"num"===e.t?Q(e)===Q(t):"str"===e.t||"key"===e.t?X(e)===X(t):"vec"===e.t?oe(Y(e),Y(t)):"dict"===e.t&&((e,t)=>{const[r,n]=[ee(e),ee(t)];return S(r.keys)===S(n.keys)&&oe(r.keys,n.keys)})(e,t),ue=({keys:e,vals:t},r)=>{const n=e.findIndex((e=>ie(e,r)));return-1===n?{t:"null",v:void 0}:t[n]};async function ce(e,r,n,s){const C=e=>[ae(e,s)];{const t=function(e,t,r){const{types:n,exactArity:s,maxArity:a,minArity:o,onlyNum:i}=V.ops[e],u=(t,n)=>[{e:"Arity",m:`${e} needs ${t} argument${1!==n?"s":""}`,errCtx:r}],c=S(t);if(void 0!==s){if(c!==s)return u(`exactly ${s}`,s)}else{if(o&&!a&&c<o)return u(`at least ${o}`,o);if(!o&&a&&c>a)return u(`at most ${a}`,a);if(o&&a&&(c<o||c>a))return u(`between ${o} and ${a}`,a)}return i?-1!==t.findIndex((e=>"num"!==e.t))?[ae("numeric arguments only",r)]:[]:n?n.map(((e,r)=>r<c&&(q(e)?!h(e,t[r].t)&&`argument ${r+1} must be either: ${e.map((e=>V.typeNames[e])).join(", ")}`:e!==t[r].t&&`argument ${r+1} must be ${V.typeNames[e]}`))).filter((e=>!!e)).map((e=>ae(e,r))):[]}(e,r,s);if(S(t))return t}switch(e){case"execute-last":return await le(n,r.pop(),s)(r);case"str":return R.push({t:"str",v:ne(r)}),[];case"print":case"print-str":return n.exe(e,[{t:"str",v:ne(r)}]),G(),[];case"vec":return z(r),[];case"dict":return R.push(se(r)),[];case"len":return L("str"===r[0].t?$(X(r[0])):"vec"===r[0].t?S(Y(r[0])):S(ee(r[0]).keys)),[];case"num":return D(r[0].v)?L(_(r[0].v)):G(),[];case"!":return W(!te(r[0])),[];case"=":case"!=":for(let t=1,n=S(r);t<n;++t)if(ie(r[t-1],r[t])!==("="===e))return W(!1),[];return W(!0),[];case"-":return L(1===S(r)?-Q(r[0]):r.map(Q).reduce(((e,t)=>e-t))),[];case"**":return L(Q(r[0])**(1===S(r)?2:Q(r[1]))),[];case"+":return L(r.map(Q).reduce(((e,t)=>e+t))),[];case"*":return L(r.map(Q).reduce(((e,t)=>e*t))),[];case"/":return L(r.map(Q).reduce(((e,t)=>e/t))),[];case"//":return L(r.map(Q).reduce(((e,t)=>p(e/t)))),[];case"rem":return L(r.map(Q).reduce(((e,t)=>e%t))),[];case"min":return L(r.map(Q).reduce(((e,t)=>v(e,t)))),[];case"max":return L(r.map(Q).reduce(((e,t)=>y(e,t)))),[];case"<":case">":case"<=":case">=":for(let t=1,n=S(r);t<n;++t){const[n,s]=[r[t-1].v,r[t].v];if("<"===e&&n>=s||">"===e&&n<=s||"<="===e&&n>s||">="===e&&n<s)return W(!1),[]}return W(!0),[];case"inc":return L(r[0].v+1),[];case"dec":return L(r[0].v-1),[];case"abs":return L(a(Q(r[0]))),[];case"pi":return L(c),[];case"sin":case"cos":case"tan":case"sqrt":case"round":case"floor":case"ceil":return L({sin:i,cos:o,tan:u,sqrt:m,round:f,floor:p,ceil:d}[e](Q(r[0]))),[];case"odd?":case"even?":return W(Q(r[0])%2==("odd?"===e?1:0)),[];case"pos?":case"neg?":case"zero?":{const t=Q(r[0]);return W("pos?"===e?t>0:"neg?"===e?t<0:!t),[]}case"null?":case"num?":case"bool?":case"str?":case"dict?":case"vec?":case"key?":case"func?":return W("null?"===e&&"null"===r[0].t||"num?"===e&&"num"===r[0].t||"bool?"===e&&"bool"===r[0].t||"str?"===e&&"str"===r[0].t||"dict?"===e&&"dict"===r[0].t||"vec?"===e&&"vec"===r[0].t||"key?"===e&&"key"===r[0].t||"func?"===e&&"func"===r[0].t),[];case"has?":return W(M(X(r[0]),X(r[1]))),[];case"idx":{let e=-1;if("str"===r[0].t){if("str"!==r[1].t)return C("strings can only contain strings");e=E(X(r[0]),X(r[1]))}else"vec"===r[0].t&&(e=Y(r[0]).findIndex((e=>ie(e,r[1]))));return-1===e?G():L(e),[]}case"map":case"for":case"reduce":case"filter":{const t=le(n,r.shift(),s),a=e=>"vec"===e||"str"===e||"dict"===e;if(-1!==("map"===e||"for"===e?r.findIndex((({t:e})=>!a(e))):a(r[0].t)?-1:0))return C("argument 2 must be either: string, vector, dictionary");if("for"===e){const e=r.map(re),a=e.map(S),o=a.map(((e,t)=>k(a,0,t+1).reduce(((e,t)=>e*t))));o.unshift(1);const i=o.pop();if(i>n.loopBudget)return[{e:"Budget",m:"would exceed loop budget",errCtx:s}];const u=[];for(let r=0;r<i;++r){const n=o.map(((e,t)=>p(r/e%a[t]))),s=await t(e.map(((e,t)=>e[n[t]])));if(S(s))return s;u.push(R.pop())}return z(u),[]}if("map"===e){const e=r.map(re),n=v(...e.map((e=>S(e)))),s=[];for(let r=0;r<n;++r){const n=await t(e.map((e=>e[r])));if(S(n))return n;s.push(R.pop())}return z(s),[]}const o=re(r.shift());if("filter"===e){const e=[];for(let r=0,n=S(o);r<n;++r){const n=await t([o[r]]);if(S(n))return n;te(R.pop())&&e.push(o[r])}return z(e),[]}if(S(o)<2)return g(R,o),[];let i=(S(r)?r:o).shift();for(let e=0,r=S(o);e<r;++e){const r=await t([i,o[e]]);if(S(r))return r;i=R.pop()}R.push(i)}return[];case"rand-int":case"rand":{const t=S(r),[n,s]=[t<2?0:Q(r[0]),0===t?1+_("rand-int"===e):Q(1===t?r[0]:r[1])];L("rand-int"===e?j(n,s):H(n,s))}return[];case"do":case"val":return R.push("do"===e?r.pop():r.shift()),[];case"..":{const e=le(n,r.shift(),s);return await e(b(r.map((e=>"vec"===e.t?Y(e):[e]))))}case"into":{const e="vec"===r[0].t,t="vec"===r[1].t;if(e)z(x(Y(r[0]),t?Y(r[1]):re(r[1])));else if(t){const e=re(r[1]);R.push(se(x(b(re(r[0]).map(Y)),e)))}else{const{keys:e,vals:t}=ee(r[0]),n=ee(r[1]);U({keys:x(e,n.keys),vals:x(t,n.vals)})}return[]}case"push":if("vec"===r[0].t)z(x(re(r[0]),[r[1]]));else{if(S(r)<3)return[{e:"Arity",m:"key and value both required",errCtx:s}];const{keys:e,vals:t}=ee(r[0]);U({keys:x(e,[r[1]]),vals:x(t,[r[2]])})}return[];case"sect":{const e=r[0],t="vec"===e.t,n=t?S(Y(e)):$(X(e));let s=0,a=n;switch(S(r)){case 1:s=1;break;case 2:{const e=Q(r[1]);e<0?a+=e:s+=e;break}case 3:{const e=Q(r[1]),t=Q(r[2]);s=e<0?n+e+(t<0?t:0):s+e,a=(t<0?a:s)+t;break}}return s=y(s,0),a=v(a,n),s>a?((t?z:Z)(),[]):(t?z(k(Y(e),s,a)):Z(I(X(r[0]),s,a-s)),[])}case"reverse":return"str"===r[0].t?Z(ne(A(re(r[0])))):z(A(re(r[0]))),[];case"sort":{if(!S(Y(r[0])))return z(),[];const e=re(r[0]),a=[];if(1===S(r))g(a,e.map((e=>[e,e])));else{const t=le(n,r.pop(),s);for(let r=0,n=S(e);r<n;++r){const n=await t([e[r]]);if(S(n))return n;a.push([e[r],R.pop()])}}const o=a[0][1].t;return a.some((([e,{t}])=>t!==o||!h(["num","str"],t)))?C("can only sort by all number or all string"):((0,t.visNum)(a[0][1])?w(a,(([e,t],[r,n])=>Q(t)>Q(n)?1:-1)):w(a,(([e,t],[r,n])=>X(t)>X(n)?1:-1)),z(a.map((([e])=>e))),[])}case"range":{const[e,t,o]=r.map(Q),i=o&&o<0&&e<t,[u,c]=S(r)>1?i?[t-1,e-1]:[e,t]:[0,e],m=l((c-u)*(o||1))*(o||1),p=d(a((c-u)/m));if(!p)return z([]),[];if(p>n.rangeBudget)return[{e:"Budget",m:"range budget depleted",errCtx:s}];n.rangeBudget-=p;const f=T(p).map((e=>e*m+u));return z(f.map((e=>({t:"num",v:e})))),[]}case"empty?":return W(!S(re(r[0]))),[];case"keys":case"vals":return z(ee(r[0])["keys"===e?"keys":"vals"]),[];case"starts-with?":return W(B(X(r[0]),X(r[1]))),[];case"ends-with?":return W(N(X(r[0]),X(r[1]))),[];case"split":return z(X(r[0]).split(S(r)>1?X(r[1]):" ").map((e=>({t:"str",v:e})))),[];case"join":return Z(Y(r[0]).map(K).join(S(r)>1?X(r[1]):" ")),[];case"time":return L(P()),[];case"version":return L(t.insituxVersion),[];case"tests":{const e=await(0,F.doTests)(de,!(S(r)&&te(r[0]))),t=e.pop();for(const t of e)await ce("print",[{v:t,t:"str"}],n,s);Z(t)}return[];case"eval":{delete n.env.funcs.entry;const e=S(R),t=await pe(n,X(r[0]),s.invocationId);return S(t)?[{e:"Eval",m:"error within evaluated code",errCtx:s}]:(e===S(R)&&G(),[])}}return[{e:"Unexpected",m:"operation doesn't exist",errCtx:s}]}function le(e,r,n){const s=[{e:"Arity",m:"one argument required",errCtx:n}];if((0,t.visStr)(r)||(0,t.visFun)(r)){const t=r.v;return V.ops[t]?r=>ce(t,r,e,n):t in e.env.funcs?r=>me(e,e.env.funcs[t],r):t in e.env.vars?le(e,e.env.vars[t],n):t in e.env.lets[S(e.env.lets)-1]?le(e,e.env.lets[S(e.env.lets)-1][t],n):B(t,"$")?async r=>{if(!S(r))return s;const a=await e.set(I(t,1),r[0]);return R.push(r[0]),a?[{e:"External",m:a,errCtx:n}]:[]}:async r=>{const{err:s,value:a}=await e.exe(t,r);return s||R.push(a),s?[{e:"External",m:s,errCtx:n}]:[]}}if((0,t.visKey)(r))return async e=>S(e)?"dict"!==e[0].t?[ae("argument 1 must be dictionary",n)]:(R.push(ue(ee(e[0]),r)),[]):s;if((0,t.visNum)(r)){const e=r.v;return async t=>{if(!S(t))return s;const r=t[0];if("str"!==r.t&&"vec"!==r.t&&"dict"!==r.t)return[ae("argument must be string, vector, or dictionary",n)];const o=re(r);return a(e)>=S(o)?G():e<0?R.push(o[S(o)+e]):R.push(o[e]),[]}}if((0,t.visVec)(r)){const{v:e}=r;return async t=>{if(!S(t))return s;const r=e.find((e=>ie(e,t[0])));return r?R.push(r):G(),[]}}if((0,t.visDic)(r)){const e=r.v;return async t=>{if(1===S(t))R.push(ue(e,t[0]));else{if(2!==S(t))return[{e:"Arity",m:"dict as operation takes one or two arguments only",errCtx:n}];R.push((({keys:e,vals:t},r,n)=>{const[s,a]=[k(e),k(t)],o=e.findIndex((e=>ie(e,r)));return-1!==o?a[o]=n:(s.push(r),a.push(n)),{t:"dict",v:{keys:s,vals:a}}})(e,t[0],t[1]))}return[]}}if((0,t.visBoo)(r)){const e=r.v;return async t=>!S(t)||S(t)>2?[{e:"Arity",m:"boolean as operation takes one or two arguments only",errCtx:n}]:(R.push(e?t[0]:S(t)>1?t[1]:{t:"null",v:void 0}),[])}return async e=>[{e:"Operation",m:`${K(r)} is an invalid operation`,errCtx:n}]}async function me(e,r,n){--e.callBudget,e.env.lets.push({});for(let a=0,o=S(r.ins);a<o;++a){const{typ:i,value:u,errCtx:c}=r.ins[a],l=e.loopBudget<1;if(l||e.callBudget<1)return[{e:"Budget",m:(l?"looped":"called")+" too many times",errCtx:c}];switch(i){case"nul":G();break;case"boo":W(u);break;case"num":L(u);break;case"str":Z(u);break;case"key":s=u,R.push({t:"key",v:s});break;case"var":e.env.vars[u]=R[S(R)-1];break;case"let":e.env.lets[S(e.env.lets)-1][u]=R[S(R)-1];break;case"par":{const e=u;-1===e?z(n):S(n)<=e?G():R.push(n[e])}break;case"ref":{const t=u;if(V.ops[t])J(t);else if(B(t,"$")){const{value:r,err:n}=await e.get(I(t,1));if(n)return[{e:"External",m:n,errCtx:c}];R.push(r)}else if(t in e.env.vars)R.push(e.env.vars[t]);else if(t in e.env.lets[S(e.env.lets)-1])R.push(e.env.lets[S(e.env.lets)-1][t]);else{if(!(t in e.env.funcs))return[{e:"Reference",m:`"${t}" did not exist`,errCtx:c}];J(t)}}break;case"op":case"exe":{let[s,i]=u;const l=C(R,S(R)-i,i);if(S(l)!==i)return[{e:"Unexpected",m:`${s} stack depleted`,errCtx:c}];if(a===o-1&&(0,t.visStr)(s)&&s.v===r.name){if(e.env.lets[S(e.env.lets)-1]={},a=-1,n=l,--e.recurBudget,!e.recurBudget)return[{e:"Budget",m:"recurred too many times",errCtx:c}];continue}const m=le(e,s,c),p=await m(l);if(S(p))return p}break;case"or":te(R[S(R)-1])?a+=u:R.pop();break;case"if":te(R.pop())||(a+=u);break;case"jmp":a+=u;break;case"loo":a+=u,--e.loopBudget;break;case"pop":C(R,S(R)-u,u);break;case"ret":C(R,0,S(R)-1),a=o}}var s;return e.env.lets.pop(),[]}async function pe(e,t,r){const s=(0,n.parse)(t,r);return S(s.errors)?s.errors:(e.env.funcs={...e.env.funcs,...s.funcs},"entry"in e.env.funcs?await me(e,e.env.funcs.entry,[]):[])}async function de(e,t,r,n=!1){const{callBudget:s,loopBudget:a,recurBudget:o,rangeBudget:i}=e,u=await pe(e,t,r);return e.env.lets=[],e.callBudget=s,e.recurBudget=o,e.loopBudget=a,e.rangeBudget=i,delete e.env.funcs.entry,!S(u)&&n&&S(R)&&await e.exe("print",[{t:"str",v:K(R[S(R)-1])}]),R=[],u}t.exeFunc=me,t.invoke=de,t.symbols=function(e){let t=["function"];return t=x(t,O(V.ops).filter((e=>"execute-last"!==e))),t=x(t,O(e.env.funcs)),t=x(t,O(e.env.vars)),t}},669:(e,t,r)=>{t.invoker=t.Z=void 0;const n=r(607),s=r(17),a=new Map;t.Z=/[\[\]\(\) ]/,t.invoker=async function(e,r){const o=(0,s.getTimeMs)().toString();a.set(o,r);const i=await(0,n.invoke)(e,r,o,!0);let u=[];return i.forEach((({e,m:r,errCtx:{line:n,col:o,invocationId:i}})=>{const c=a.get(i).split("\n")[n-1],l=(0,s.substr)(c,o-1).split(t.Z)[0],m=(0,s.trimStart)((0,s.substr)(c,0,o-1));if(u.push({type:"message",text:(0,s.padEnd)(`${n}`,4)+m}),l){const e=(0,s.substr)(c,o-1+l.length);u.push({type:"error",text:l}),u.push({type:"message",text:`${e}\n`})}else{const e=(0,s.substr)(c,o);u.push({type:"error",text:c[o-1]}),u.push({type:"message",text:`${e}\n`})}u.push({type:"message",text:`${e} Error: ${r}.\n`})})),u}},306:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parse=void 0;const n=r(17),{concat:s,has:a,flat:o,push:i,slice:u}=n,{slen:c,starts:l,sub:m,substr:p,strIdx:d}=n,{isNum:f,len:y,toNum:v}=n,x=r(699);function h(e,t){if(!y(e))return[];const{typ:r,text:n,errCtx:s}=e.shift();switch(r){case"str":return[{typ:"str",value:n,errCtx:s}];case"num":return[{typ:"num",value:v(n),errCtx:s}];case"sym":if("true"===n||"false"===n)return[{typ:"boo",value:"true"===n,errCtx:s}];if("null"===n)return[{typ:"nul",value:void 0,errCtx:s}];if(l(n,":"))return[{typ:"key",value:n,errCtx:s}];if(l(n,"#")&&f(p(n,1))){const e=v(p(n,1));return e<0?[{typ:"nul",errCtx:s}]:[{typ:"par",value:e,errCtx:s}]}return a(t,n)?[{typ:"par",value:t.indexOf(n),errCtx:s}]:"args"===n?[{typ:"par",value:-1,errCtx:s}]:[{typ:"ref",value:n,errCtx:s}];case"ref":return[{typ:"def",value:n,errCtx:s}];case"(":{const r=e.shift();if(!r)break;const{typ:n,text:s,errCtx:o}=r;let u=s;const c=e=>[{typ:"err",value:e,errCtx:o}];if("var"===u||"let"===u){const[r,n]=[h(e,t),h(e,t)];return y(r)&&y(n)&&!y(h(e,t))?[...n,{typ:u,value:r[0].value,errCtx:o}]:c("must provide reference name and value only")}if("if"===u||"when"===u){const r=h(e,t);if(!y(r))return c("must provide condition");const n=r;if("if"===u){const r=h(e,t);if(!y(r))return c("must provide a branch");n.push({typ:"if",value:y(r)+1,errCtx:o}),i(n,r);const s=h(e,t);if(y(s)){if(n.push({typ:"jmp",value:y(s),errCtx:o}),i(n,s),y(h(e,t)))return c("too many branches")}else n.push({typ:"jmp",value:1,errCtx:o}),n.push({typ:"nul",value:void 0,errCtx:o})}else{const r=[];for(;;){const n=h(e,t);if(!y(n))break;i(r,n)}n.push({typ:"if",value:y(r)+1,errCtx:o}),i(n,r),n.push({typ:"jmp",value:1,errCtx:o}),n.push({typ:"nul",value:void 0,errCtx:o})}return n}if("and"===u||"or"===u||"while"===u){const r=[];let n=0;for(;;){const s=h(e,t);if(!y(s))break;r.push(s),n+=y(s)}if(y(r)<2)return c("requires at least two arguments");const s=[];if("while"===u){n+=2;const e=r.shift();return i(s,e),s.push({typ:"if",value:n-y(e),errCtx:o}),r.forEach((e=>i(s,e))),s.push({typ:"pop",value:y(r),errCtx:o}),s.push({typ:"loo",value:-(n+1),errCtx:o}),s}n+=y(r),n+=v("and"===u);const a="and"===u?"if":"or";for(let e=0;e<y(r);++e)i(s,r[e]),n-=y(r[e]),s.push({typ:a,value:n,errCtx:o}),--n;return"and"===u?i(s,[{typ:"boo",value:!0,errCtx:o},{typ:"jmp",value:1,errCtx:o},{typ:"boo",value:!1,errCtx:o}]):s.push({typ:"boo",value:!1,errCtx:o}),s}const m=[];let p=0;if("("===n||a(t,s)||l(s,"#")){e.unshift(r);const n=h(e,t);i(m,n),u="execute-last",++p}const d=[];for(;y(e);){const r=h(e,t);if(!y(r))break;++p,i(d,r)}return"return"===u?[...d,{typ:"ret",errCtx:o}]:(m.push({typ:x.ops[u]?"op":"exe",value:["num"===n?{t:"num",v:v(u)}:l(u,":")?{t:"key",v:u}:x.ops[u]?{t:"func",v:u}:"true"===u||"false"===u?{t:"bool",v:"true"===u}:{t:"str",v:u},p],errCtx:o}),[...d,...m])}}return[]}t.parse=function(e,t){const{tokens:r,stringError:n}=function(e,t){const r=[];let n=!1,s=!1,a=[0,0],o=!1,i=!1,u=!1,l=1,p=0;for(let f=0,v=c(e);f<v;++f){const c=d(e,f),x=f+1!==v?d(e,f+1):"";if(++p,u){"\n"===c&&(u=!1,++l,p=0);continue}if(s){s=!1,n&&(r[y(r)-1].text+={n:"\n",t:"\t"}[c]||`\\${c}`);continue}if("\\"===c){s=!0;continue}if('"'===c){(n=!n)&&(a=[l,p],r.push({typ:"str",text:"",errCtx:{invocationId:t,line:l,col:p}})),i=o=!1;continue}const h=m(" \t\n\r",c);if(!n&&h){i=o=!1,"\n"===c&&(++l,p=0);continue}if(!n&&";"===c){u=!0;continue}const b={invocationId:t,line:l,col:p},g=e=>m("0123456789",e),A=m("()[]{}",c);if(i&&!g(c)&&(i="."===c&&!m(r[y(r)-1].text,"."),i||A||h||(o=!0,r[y(r)-1].typ="sym")),o&&A&&(o=!1),!n&&!o&&!i){if(A){const e={"[":"(","{":"(","(":"(",")":")","}":")","]":")"}[c];r.push({typ:e,text:e,errCtx:b}),"["===c?r.push({typ:"sym",text:"vec",errCtx:b}):"{"===c&&r.push({typ:"sym",text:"dict",errCtx:b});continue}i=g(c)||"."===c&&g(x)||"-"===c&&(g(x)||"."===x),o=!i;let e=o?"sym":"num";if(y(r)){const{typ:t,text:n}=r[y(r)-1];"sym"!==t||"var"!==n&&"let"!==n||(e="ref")}r.push({typ:e,text:"",errCtx:b})}r[y(r)-1].text+=c}return{tokens:r,stringError:n?a:void 0}}(e,t),a=function(e,t,r){const n=[],s=(e,t)=>n.push({e:"Parse",m:e,errCtx:t}),a=e=>y(t.filter((({typ:t})=>t===e))),[o,i]=[a("("),a(")")];{const[e,n]=function(e,t,r){const n=r>=t,[s,a]=[n?"(":")",n?")":"("],o=n?1:-1;for(let t=y(e),r=n?0:t-1,i=0;n?r<t:r>=0;r+=o){const{typ:t,errCtx:{line:n,col:o}}=e[r];if(i+=v(t===s)-v(t===a),i<0)return[n,o]}return[0,0]}(t,o,i);e+n&&s("unmatched parenthesis",{invocationId:r,line:e,col:n})}if(e){const[t,n]=e;s("unmatched double quotation marks",{invocationId:r,line:t,col:n})}let u;for(let e=0,r=!1;e<y(t);++e){if(r&&")"===t[e].typ){u=t[e];break}r="("===t[e].typ}return u&&s("empty expression forbidden",u.errCtx),n}(n,r,t);if(y(a))return{errors:a,funcs:{}};const l=function(e){const t=e=>y(e)>1&&"sym"===e[1].typ&&"function"===e[1].text,r=e.filter((e=>t(e))),n=o(e.filter((e=>!t(e)))),a=r.map((e=>({name:e[2].text,tokens:u(e,3),errCtx:e[2].errCtx})));return y(n)?s(a,[{name:"entry",tokens:n,errCtx:n[0].errCtx}]):a}(function(e){const t=[[]];let r=0;return e.forEach((e=>{t[y(t)-1].push(e),r+=v("("===e.typ)-v(")"===e.typ),0===r&&t.push([])})),t}(r)).map((e=>function({name:e,tokens:t},r){const[n,s]=function(e,t){const r=[],n=[];for(let t=0,s=!1;t<y(e);++t)s||(s="sym"!==e[t].typ),(s?n:r).push(e[t]);return[r,n]}(t);if(!y(n)&&!y(s))return{err:{e:"Parse",m:"empty function body",errCtx:r}};if(y(s)&&")"===s[0].typ){if(!y(n))return{err:{e:"Parse",m:"empty function body",errCtx:r}};s.unshift(n.pop())}y(n)&&!y(s)&&s.push(n.pop());const a=[];for(;y(s);)i(a,h(s,n.map((e=>e.text))));const o=a.filter((e=>"err"===e.typ));return y(o)?{err:{e:"Parse",m:o[0].value,errCtx:o[0].errCtx}}:{func:{name:e,ins:a}}}(e,{invocationId:t,line:e.errCtx.line,col:e.errCtx.col}))),[p,f]=function(e,t){const r=[],n=[];return e.forEach((e=>{return(t=e,t.err?n:r).push(e);var t})),[r,n]}(l);i(a,f.map((e=>e.err)));const x={};return p.forEach((({func:e})=>x[e.name]=e)),{errors:a,funcs:x}}},17:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.pi=t.sign=t.ceil=t.floor=t.round=t.sqrt=t.tan=t.cos=t.sin=t.max=t.min=t.abs=t.getTimeMs=t.objKeys=t.range=t.randInt=t.randNum=t.padEnd=t.trimStart=t.trim=t.reverse=t.sortBy=t.push=t.concat=t.flat=t.ends=t.starts=t.has=t.subIdx=t.sub=t.strIdx=t.substr=t.isArray=t.isNum=t.slen=t.len=t.splice=t.slice=t.toNum=void 0,t.toNum=e=>Number(e),t.slice=(e,t,r)=>e.slice(t,r),t.splice=(e,t,r)=>e.splice(t,r),t.len=e=>e.length,t.slen=e=>e.length,t.isNum=e=>!Number.isNaN(Number(e)),t.isArray=e=>Array.isArray(e),t.substr=(e,t,r)=>e.substring(t,t+(r??e.length)),t.strIdx=(e,t)=>e[t],t.sub=(e,t)=>e.includes(t),t.subIdx=(e,t)=>e.indexOf(t),t.has=(e,t)=>e.includes(t),t.starts=(e,t)=>e.startsWith(t),t.ends=(e,t)=>e.endsWith(t),t.flat=e=>e.flat(),t.concat=(e,t)=>e.concat(t),t.push=(e,t)=>e.push(...t),t.sortBy=(e,t)=>e.sort(t),t.reverse=e=>e.reverse(),t.trim=e=>e.trim(),t.trimStart=e=>e.trimStart(),t.padEnd=(e,t)=>e.padEnd(t),t.randNum=(e,t)=>e+Math.random()*(t-e),t.randInt=(e,r)=>Math.floor((0,t.randNum)(e,r)),t.range=e=>[...Array(e).keys()],t.objKeys=e=>Object.keys(e),t.getTimeMs=()=>(new Date).getTime(),t.abs=Math.abs,t.min=Math.min,t.max=Math.max,t.sin=Math.sin,t.cos=Math.cos,t.tan=Math.tan,t.sqrt=Math.sqrt,t.round=Math.round,t.floor=Math.floor,t.ceil=Math.ceil,t.sign=Math.sign,t.pi=Math.PI},127:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.doTests=void 0;const n=r(17);async function s(e,t){return e.dict.has(t)?{value:e.dict.get(t),err:void 0}:{value:{t:"null",v:void 0},err:`"${t} not found.`}}async function a(e,t,r){e.dict.set(t,r)}async function o(e,t,r){const n={t:"null",v:void 0};switch(t){case"print-str":e.output+=r[0].v;break;case"print":case"test.function":e.output+=r[0].v+"\n";break;default:return{value:n,err:"operation does not exist"}}return{value:n,err:void 0}}const i=[{name:"Hello, world!",code:'"Hello, world!"',out:"Hello, world!"},{name:"Say Hello, world!",code:'(print "Hello, world!")',out:"Hello, world!\nnull"},{name:"1 + 1 = 2",code:"(+ 1 1)",out:"2"},{name:"Negate 1 = -1",code:"(- 1)",out:"-1"},{name:"(1+1)+1+(1+1) = 5",code:"(+ (+ 1 1) 1 (+ 1 1))",out:"5"},{name:"Conditional head",code:"((if true + -) 12 9 1)",out:"22"},{name:"Whens",code:'[(when 123 (print "hi") 234) (when false (print "bye"))]',out:"hi\n[234 null]"},{name:"Cond number head",code:"((if false 1 2) [:a :b :c])",out:":c"},{name:"and & short-circuit",code:"[(and true (if true null 1) true) (and 1 2 3)]",out:"[false true]"},{name:"or & short-circuit",code:'[(or true (print "hello") 1) (or false (print-str "-> ") 1)]',out:"-> [true 1]"},{name:"String retrieve",code:'(2 "Hello")',out:"l"},{name:"Vector retrieve",code:"(2 [:a :b :c :d])",out:":c"},{name:"Key as operation",code:'(:age {:name "Patrick" :age 24})',out:"24"},{name:"Dictionary as op 1",code:'({"name" "Patrick" "age" 24} "age")',out:"24"},{name:"Dictionary as op 2",code:'({"name" "Patrick"} "age" 24)',out:"{name Patrick, age 24}"},{name:"Equalities",code:'[(= 1 2 1)\n            (!= 1 2 1)\n            (= "Hello" "hello")\n            (!= "world" "world")\n            (= [0 [1]] [0 [1]])]',out:"[false true false false true]"},{name:"Define and retrieve",code:"(var a 1) a",out:"1"},{name:"Define and add",code:"(var a 1) (inc a)",out:"2"},{name:"Define op and call",code:"(var f +) (f 2 2)",out:"4"},{name:"Define vec and call",code:"(var f [1]) (f 1)",out:"1"},{name:"Define num and call",code:"(var f 1) (f [:a :b :c])",out:":b"},{name:"Print simple vector",code:"[1 2 3]",out:"[1 2 3]"},{name:"Boolean select",code:"[(true 1 2) (false 1)]",out:"[1 null]"},{name:"Sum vector of numbers",code:"[(reduce + [1 2 3]) (reduce + [1 2 3] 3)]",out:"[6 9]"},{name:"Sum vectors of numbers",code:"(map + [1 2 3] [1 2 3 4])",out:"[2 4 6]"},{name:"Filter by integer",code:'(filter 2 [[1] [:a :b :c] "hello" "hi"])',out:"[[:a :b :c] hello]"},{name:"Comments, short decimal",code:';((print "Hello")\n           .456',out:"0.456"},{name:"Dictionary into vector",code:"(into [1 2] {3 4 5 6})",out:"[1 2 [3 4] [5 6]]"},{name:"Vector into dictionary",code:"(into {[0] 1 [2] 3} [[0] 2])",out:"{[0] 2, [2] 3}"},{name:"While loop",code:"(var n 5)\n           (while (< 0 n)\n             (print-str n)\n             (var n (dec n)))",out:"543215"},{name:"Define with no call",code:'(function func (print "Nothing."))'},{name:"Call greet func",code:'(function greeting (print "Hello!")) (greeting)',out:"Hello!\nnull"},{name:"Call const value func",code:"(function const 123) (const)",out:"123"},{name:"Call identity funcs",code:"(function id1 #)\n           (function id2 x x)\n           [(id1 123) (id2 456)]",out:"[123 456]"},{name:"Call greet with name",code:'(function greeting name (print "Hello, " name "!"))\n           (greeting "Patrick")',out:"Hello, Patrick!\nnull"},{name:"Call with too few args",code:"(function func a b c [a b c]) (func 1 2)",out:"[1 2 null]"},{name:"Define func and call",code:"(function func a b (+ a b)) (var f func) (f 2 2)",out:"4"},{name:"Anonymous parameters",code:"(function avg<n? (< (/ (.. + #) (len #)) #1))\n           (avg<n? [0 10 20 30 40] 5)",out:"false"},{name:"Call parameter",code:'(function f x (x "hello")) (f print)',out:"hello\nnull"},{name:"Let and retrieve",code:"(function f (let a 1) a) (f)",out:"1"},{name:"Let num op and call",code:"(function f (let n 0) (n [0])) (f)",out:"0"},{name:"Explicit return",code:"(function f (return 123) (print 456)) (f)",out:"123"},{name:"String instead of number",code:'(function sum (.. + args))\n           (print (sum 2 2))\n           (sum 2 "hi")',out:"4",err:["Type"]},{name:"Reference non-existing",code:"x",err:["Reference"]},{name:"Expired let retrieve",code:"(function f (let a 1) a) (f) a",err:["Reference"]},{name:"Call non-existing",code:"(x)",err:["External"]},{name:"Call budget",code:"(function f (f)) (f)",err:["Budget"]},{name:"Loop budget",code:"(var n 10000)\n           (while (< 0 n)\n             (var n (dec n)))",err:["Budget"]},{name:"Range budget",code:"(range 10000)",err:["Budget"]},{name:"Fibonacci 13",code:"(function fib n\n             (if (< n 2) n\n               (+ (fib (dec n))\n                  (fib (- n 2)))))\n           (fib 13)",out:"233"},{name:"dedupe (tail-call optim)",code:"(function dedupe list -out\n             (let out (or -out []))\n             (let next (if (out (0 list)) [] [(0 list)]))\n             (if (empty? list) out\n                 (dedupe (sect list) (into out next))))\n           (dedupe [1 1 2 3 3 3])",out:"[1 2 3]"},{name:"set get",code:"[($globals.time_offset 5.5) $globals.time_offset]",out:"[5.5 5.5]"},{name:"exe",code:"(test.function 123)",out:"123\nnull"},{name:"Empty parens",code:"()",err:["Parse"]},{name:"Imbalanced parens 1",code:'(print ("hello!")',err:["Parse"]},{name:"Imbalanced parens 2",code:'print "hello!")',err:["Parse"]},{name:"Imbalanced quotes 1",code:'(print "Hello)',err:["Parse","Parse"]},{name:"Imbalanced quotes 2",code:'print "Hello")',err:["Parse"]},{name:"Function as op",code:"(function)",err:["Parse"]},{name:"Function without body",code:"(function func)",err:["Parse"]}];t.doTests=async function(e,t=!0){const r=[];for(let t=0;t<(0,n.len)(i);++t){const{name:u,code:c,err:l,out:m}=i[t],p={dict:new Map,output:""},d={funcs:{},vars:{},lets:[]},f=(0,n.getTimeMs)(),y=await e({get:e=>s(p,e),set:(e,t)=>a(p,e,t),exe:(e,t)=>o(p,e,t),env:d,loopBudget:1e4,rangeBudget:1e3,callBudget:1e3,recurBudget:1e4},c,"testing",!0),v=(l||[]).join()===y.map((({e})=>e)).join(),x=!m||(0,n.trim)(p.output)===m,h=(0,n.getTimeMs)()-f,[b,g,A,k]=[(0,n.padEnd)(`${t+1}`,3),(0,n.padEnd)(u,24),(0,n.padEnd)(`${h}ms`,6),v||y.map((({e,m:t,errCtx:{line:r,col:n}})=>`${e} ${r}:${n}: ${t}`))];r.push({okErr:v,okOut:x,elapsedMs:h,display:`${b} ${g} ${A} ${x} ${k}`})}const u=r.reduce(((e,{elapsedMs:t})=>e+t),0),c=(0,n.len)(r.filter((({okOut:e,okErr:t})=>e&&t)));return(0,n.concat)(r.filter((e=>!t||!e.okOut||!e.okErr)).map((e=>e.display)),[`----- ${c}/${(0,n.len)(r)} tests passed in ${u}ms.`])}},699:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.typeNames=t.ops=void 0,t.ops={print:{},"print-str":{},"execute-last":{},"!":{exactArity:1},"=":{minArity:2},"!=":{minArity:2},"+":{minArity:2,onlyNum:!0},"-":{minArity:1,onlyNum:!0},"*":{minArity:2,onlyNum:!0},"/":{minArity:2,onlyNum:!0},"//":{minArity:2,onlyNum:!0},"**":{minArity:1,onlyNum:!0},"<":{minArity:2,onlyNum:!0},">":{minArity:2,onlyNum:!0},"<=":{minArity:2,onlyNum:!0},">=":{minArity:2,onlyNum:!0},inc:{exactArity:1,onlyNum:!0},dec:{exactArity:1,onlyNum:!0},min:{minArity:2,onlyNum:!0},max:{minArity:2,onlyNum:!0},abs:{exactArity:1,onlyNum:!0},pi:{exactArity:0},sqrt:{exactArity:1,onlyNum:!0},round:{exactArity:1,onlyNum:!0},floor:{exactArity:1,onlyNum:!0},ceil:{exactArity:1,onlyNum:!0},"odd?":{exactArity:1,onlyNum:!0},"even?":{exactArity:1,onlyNum:!0},"pos?":{exactArity:1,onlyNum:!0},"neg?":{exactArity:1,onlyNum:!0},"zero?":{exactArity:1,onlyNum:!0},"null?":{exactArity:1},"num?":{exactArity:1},"bool?":{exactArity:1},"str?":{exactArity:1},"vec?":{exactArity:1},"dict?":{exactArity:1},"key?":{exactArity:1},"func?":{exactArity:1},rem:{minArity:2,onlyNum:!0},sin:{exactArity:1,onlyNum:!0},cos:{exactArity:1,onlyNum:!0},tan:{exactArity:1,onlyNum:!0},vec:{},dict:{},len:{exactArity:1,types:[["str","vec","dict"]]},num:{exactArity:1,types:[["str","num"]]},"has?":{exactArity:2,types:["str","str"]},idx:{exactArity:2,types:[["str","vec"]]},map:{minArity:2},for:{minArity:2},reduce:{minArity:2,maxArity:3},filter:{exactArity:2},str:{},rand:{maxArity:2,onlyNum:!0},"rand-int":{maxArity:2,onlyNum:!0},while:{},"..":{minArity:2},into:{exactArity:2,types:[["vec","dict"],["vec","dict"]]},push:{minArity:2,maxArity:3,types:[["vec","dict"]]},sect:{minArity:1,maxArity:3,types:[["vec","str"],"num","num"]},reverse:{exactArity:1,types:[["vec","str"]]},sort:{minArity:1,maxArity:2,types:["vec"]},keys:{exactArity:1,types:["dict"]},vals:{exactArity:1,types:["dict"]},do:{minArity:1},val:{minArity:1},range:{minArity:1,maxArity:3,types:["num","num","num"]},"empty?":{exactArity:1,types:[["str","vec","dict"]]},"starts-with?":{exactArity:2,types:["str","str"]},"ends-with?":{exactArity:2,types:["str","str"]},split:{minArity:1,maxArity:2,types:["str","str"]},join:{minArity:1,maxArity:2,types:["vec","str"]},time:{exactArity:0},version:{exactArity:0},tests:{minArity:0,maxArity:1,types:["bool"]},eval:{exactArity:1,types:["str"]}},t.typeNames={null:"null",str:"string",num:"number",bool:"boolean",key:"keyword",ref:"reference",vec:"vector",dict:"dictionary",func:"function"}}},t={},r=function r(n){var s=t[n];if(void 0!==s)return s.exports;var a=t[n]={exports:{}};return e[n](a,a.exports,r),a.exports}(669);window.insitux=r.invoker})();