{"version":3,"file":"insitux-tokenise.js","mappings":"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","sources":["webpack://insituxTokenise/webpack/bootstrap","webpack://insituxTokenise/webpack/runtime/define property getters","webpack://insituxTokenise/webpack/runtime/hasOwnProperty shorthand","webpack://insituxTokenise/webpack/runtime/make namespace object","webpack://insituxTokenise/./src/poly-fills.ts","webpack://insituxTokenise/./src/parse.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export const toNum = (x: unknown): number => Number(x); //Should also support 0b and 0x\nexport const slice = <T>(arr: T[], start?: number, end?: number): T[] =>\n  arr.slice(start, end);\nexport const splice = <T>(arr: T[], start: number, numDel?: number): T[] =>\n  arr.splice(start, numDel);\nexport const len = <T>(arr: T[]): number => arr.length;\nexport const slen = (str: string): number => str.length;\nexport const isNum = (x: unknown): x is number => !Number.isNaN(Number(x));\nexport const isArray = <T>(x: unknown): x is T[] => Array.isArray(x);\nexport const substr = (str: string, start: number, length?: number): string =>\n  str.substring(start, start + (length ?? str.length));\nexport const strIdx = (str: string, idx: number): string => str[idx];\nexport const sub = (x: string, s: string): boolean => x.includes(s);\nexport const subIdx = (x: string, s: string) => x.indexOf(s);\nexport const has = <T>(x: T[], y: T): boolean => x.includes(y);\nexport const starts = (str: string, prefix: string): boolean =>\n  str.startsWith(prefix);\nexport const ends = (str: string, x: string): boolean => str.endsWith(x);\nexport const flat = <T>(arr: T[][]): T[] => arr.flat(); //e.g. [[0], [1], []] => [0, 1]\nexport const concat = <T>(a: T[], b: T[]): T[] => a.concat(b);\nexport const push = <T>(arr: T[], add: T[]) => arr.push(...add);\nexport const sortBy = <T>(arr: T[], by: (a: T, b: T) => number) => arr.sort(by);\nexport const reverse = <T>(arr: T[]) => arr.reverse();\nexport const lowerCase = (str: string) => str.toLowerCase();\nexport const upperCase = (str: string) => str.toUpperCase();\nexport const trim = (str: string) => str.trim();\nexport const trimStart = (str: string) => str.trimStart();\nexport const trimEnd = (str: string) => str.trimEnd();\nexport const padEnd = (str: string, by: number) => str.padEnd(by);\nexport const charCode = (str: string): number => str.charCodeAt(0);\nexport const codeChar = (num: number): string => String.fromCharCode(num);\nexport const randNum = (a: number, b: number) => a + Math.random() * (b - a);\nexport const randInt = (a: number, b: number) => Math.floor(randNum(a, b));\nexport const range = (len: number) => [...Array(len).keys()];\nexport const objKeys = (x: object) => Object.keys(x);\nexport const getTimeMs = () => new Date().getTime();\nexport const abs = Math.abs;\nexport const min = Math.min;\nexport const max = Math.max;\nexport const sin = Math.sin;\nexport const cos = Math.cos;\nexport const tan = Math.tan;\nexport const sqrt = Math.sqrt;\nexport const round = Math.round;\nexport const floor = Math.floor;\nexport const ceil = Math.ceil;\nexport const sign = Math.sign;\nexport const logn = Math.log;\nexport const log2 = Math.log2;\nexport const log10 = Math.log10;\n","import { arityCheck, keyOpErr, numOpErr, typeCheck } from \"./checks\";\nimport * as pf from \"./poly-fills\";\nconst { has, flat, push, slice, splice } = pf;\nconst { slen, starts, sub, substr, strIdx, subIdx } = pf;\nconst { isNum, len, toNum } = pf;\nimport { ParamsShape, ErrCtx, Func, Funcs, Ins, ops, Val } from \"./types\";\nimport { assertUnreachable, InvokeError } from \"./types\";\n\ntype Token = {\n  typ: \"str\" | \"num\" | \"sym\" | \"rem\" | \"(\" | \")\";\n  text: string;\n  errCtx: ErrCtx;\n};\ntype Node = Token | Node[];\ntype ParserIns = Ins | { typ: \"err\"; value: string; errCtx: ErrCtx };\nconst nullVal: Val = { t: \"null\", v: undefined };\nconst falseVal = <Val>{ t: \"bool\", v: false };\ntype NamedNodes = {\n  name: string;\n  nodes: Node[];\n};\nconst isToken = (node: Node | undefined): node is Token =>\n  !!node && \"errCtx\" in node;\nconst symAt = (node: Node, pos = 0) => {\n  if (isToken(node)) {\n    return \"\";\n  }\n  const arg = node[pos];\n  return (isToken(arg) && has([\"sym\", \"str\"], arg.typ) && arg.text) || \"\";\n};\nconst node2str = (nodes: Node[]): string =>\n  nodes.map(n => (isToken(n) ? n.text : `(${node2str(n)})`)).join(\" \");\n\nexport function tokenise(\n  code: string,\n  invokeId: string,\n  makeCollsOps = true,\n  emitComments = false,\n) {\n  const tokens: Token[] = [];\n  const isDigit = (ch: string) => sub(\"0123456789\", ch);\n  let [inString, line, col, inStringAt] = [false, 1, 0, [1, 0]];\n  let [inSymbol, inNumber, inHex] = [false, false, false];\n  for (let i = 0, l = slen(code); i < l; ++i) {\n    const c = strIdx(code, i),\n      nextCh = i + 1 !== l ? strIdx(code, i + 1) : \"\";\n    ++col;\n    if (c === \"\\\\\" && inString) {\n      tokens[len(tokens) - 1].text +=\n        { n: \"\\n\", t: \"\\t\", r: \"\\r\", '\"': '\"' }[nextCh] ||\n        (nextCh === \"\\\\\" ? \"\\\\\" : `\\\\${nextCh}`);\n      ++col;\n      ++i;\n      continue;\n    }\n    const errCtx: ErrCtx = { invokeId, line, col };\n    if (c === '\"') {\n      if ((inString = !inString)) {\n        inStringAt = [line, col];\n        tokens.push({ typ: \"str\", text: \"\", errCtx });\n      }\n      inNumber = inSymbol = false;\n      continue;\n    }\n    const isWhite = sub(\" \\t\\n\\r,\", c);\n    if (!inString && isWhite) {\n      inNumber = inSymbol = false;\n      if (c === \"\\n\") {\n        ++line;\n        col = 0;\n      }\n      continue;\n    }\n    if (!inString && c === \";\") {\n      const nl = subIdx(substr(code, ++i), \"\\n\");\n      const text = substr(code, i, nl > 0 ? nl : l - i);\n      i += slen(text);\n      ++line;\n      col = 0;\n      if (emitComments) {\n        tokens.push({ typ: \"rem\", text, errCtx });\n      }\n      continue;\n    }\n    const isParen = sub(\"()[]{}\", c);\n    //Allow one . per number, or hex, or binary, else convert into symbol\n    if (inNumber && !isDigit(c)) {\n      const hexStart = c === \"x\" && tokens[len(tokens) - 1].text === \"0\";\n      inHex = inHex || hexStart;\n      inNumber =\n        (c === \"b\" && tokens[len(tokens) - 1].text === \"0\") ||\n        (c === \".\" && !sub(tokens[len(tokens) - 1].text, \".\")) ||\n        (inHex && (hexStart || sub(\"ABCDEFabcdef\", c)));\n      if (!inNumber && !isParen && !isWhite) {\n        inSymbol = true;\n        tokens[len(tokens) - 1].typ = \"sym\";\n      }\n    }\n    //Stop scanning symbol if a paren\n    if (inSymbol && isParen) {\n      inSymbol = false;\n    }\n    //If we just finished concatenating a token\n    if (!inString && !inSymbol && !inNumber) {\n      if (isParen) {\n        const text = subIdx(\"[{(\", c) === -1 ? \")\" : \"(\";\n        tokens.push({ typ: text, text: makeCollsOps ? text : c, errCtx });\n        if (makeCollsOps && (c === \"[\" || c === \"{\")) {\n          tokens.push({ typ: \"sym\", text: c === \"[\" ? \"vec\" : \"dict\", errCtx });\n        }\n        continue;\n      }\n      inNumber =\n        isDigit(c) ||\n        (c === \".\" && isDigit(nextCh)) ||\n        (c === \"-\" && (isDigit(nextCh) || nextCh === \".\"));\n      inHex = inSymbol = !inNumber;\n      const typ: Token[\"typ\"] = inSymbol ? \"sym\" : \"num\";\n      tokens.push({ typ, text: \"\", errCtx });\n    }\n    tokens[len(tokens) - 1].text += c;\n  }\n  return { tokens, stringError: inString ? inStringAt : undefined };\n}\n\n/** Parses tokens into a tree where each node is a token or token list. */\nfunction treeise(tokens: Token[]): Node[] {\n  const nodes: Node[] = [];\n  const _treeise = (tokens: Token[]): Node => {\n    let prefix: Token | undefined;\n    if (tokens[0].typ === \"sym\" && sub(\"@#\", tokens[0].text)) {\n      prefix = tokens.shift()!;\n    }\n    const token = tokens.shift()!;\n    if (token.typ !== \"(\" && token.typ !== \")\") {\n      return token;\n    }\n    const nodes: Node[] = prefix ? [prefix] : [];\n    while (tokens[0].typ !== \")\") {\n      nodes.push(_treeise(tokens));\n    }\n    tokens.shift();\n    return nodes;\n  };\n  while (len(tokens)) {\n    nodes.push(_treeise(tokens));\n  }\n  return nodes;\n}\n\n/** Separates function nodes and non-function nodes,\n * with non-function nodes collected into (function entry ...)\n * if there are any.*/\nfunction collectFuncs(\n  nodes: Node[],\n): ({ name: string; nodes: Node[] } | { err: string; errCtx: ErrCtx })[] {\n  const funcs: ReturnType<typeof collectFuncs> = [];\n  const entries: Node[] = [];\n  nodes.forEach(node => {\n    if (!isToken(node) && isToken(node[0]) && symAt(node) === \"function\") {\n      const name = symAt(node, 1);\n      if (!name) {\n        funcs.push({ err: \"nameless function\", errCtx: node[0].errCtx });\n      } else if (len(node) < 3) {\n        funcs.push({ err: \"empty function body\", errCtx: node[0].errCtx });\n      }\n      funcs.push({ name, nodes: slice(node, 2) });\n    } else {\n      entries.push(node);\n    }\n  });\n  if (len(entries)) {\n    funcs.push({ name: \"entry\", nodes: entries });\n  }\n  return funcs;\n}\n\nconst parseNode = (node: Node, params: ParamsShape) =>\n  isToken(node) ? parseArg(node, params) : parseForm(node, params);\n\nfunction parseForm(\n  nodes: Node[],\n  params: ParamsShape,\n  doArityCheck = true,\n): ParserIns[] {\n  if (!len(nodes)) {\n    return [];\n  }\n  const nodeParser = (node: Node) => parseNode(node, params);\n  let firstNode = nodes.shift()!;\n  let head = nodeParser(firstNode);\n  const { errCtx } = head[0];\n  if (isToken(firstNode) && firstNode.typ === \"sym\") {\n    //1-off arity deficiency rewritten as closure\n    if (firstNode.text in ops) {\n      const { exactArity, minArity } = ops[firstNode.text];\n      const a = exactArity ?? minArity;\n      if (a && a !== 1 && len(nodes) + 1 === a) {\n        nodes.unshift(firstNode);\n        firstNode = { typ: \"sym\", text: \"@\", errCtx: firstNode.errCtx };\n      }\n    }\n    if (has([\"var\", \"let\"], firstNode.text) && len(nodes) && len(nodes) % 2) {\n      nodes.unshift(firstNode);\n      nodes.push({ typ: \"sym\", text: \"%\", errCtx: firstNode.errCtx });\n      firstNode = { typ: \"sym\", text: \"#\", errCtx: firstNode.errCtx };\n    }\n    const { text: op, errCtx } = firstNode;\n    const err = (m: string, eCtx = errCtx) => [\n      <ParserIns>{ typ: \"err\", value: m, errCtx: eCtx },\n    ];\n\n    if (has([\"if\", \"if!\", \"when\", \"match\"], op) && !len(nodes)) {\n      return err(\"provide a condition\");\n    } else if (has([\"if\", \"if!\"], op)) {\n      if (len(nodes) === 1) {\n        return err(\"provide at least one branch\");\n      } else if (len(nodes) > 3) {\n        return err(\"provide fewer than two branches\");\n      }\n      const parsed = nodes.map(nodeParser);\n      const [cond, branch1] = parsed;\n      let branch2 = parsed[2];\n      const ifN = op === \"if!\" && [\n        <Ins>{ typ: \"val\", value: { t: \"func\", v: \"!\" }, errCtx },\n        <Ins>{ typ: \"exe\", value: 1, errCtx },\n      ];\n      if (!branch2) {\n        branch2 = [{ typ: \"val\", value: nullVal, errCtx }];\n      }\n      return [\n        ...cond,\n        ...(ifN || []),\n        { typ: \"if\", value: len(branch1) + 1, errCtx },\n        ...branch1,\n        { typ: \"jmp\", value: len(branch2), errCtx },\n        ...branch2,\n      ];\n    } else if (op === \"when\") {\n      if (len(nodes) === 1) {\n        return err(\"provide a body\");\n      }\n      const parsed = nodes.map(nodeParser);\n      const [cond, body] = [parsed[0], slice(parsed, 1)];\n      const bodyIns = flat(body);\n      return [\n        ...cond,\n        { typ: \"if\", value: len(bodyIns) + 1, errCtx },\n        ...bodyIns,\n        { typ: \"jmp\", value: 1, errCtx },\n        { typ: \"val\", value: nullVal, errCtx },\n      ];\n    } else if (op === \"match\") {\n      const parsed = nodes.map(nodeParser);\n      const [cond, args] = [parsed[0], slice(parsed, 1)];\n      const otherwise: ParserIns[] = len(args) % 2 ? args.pop()! : [];\n      if (!len(args)) {\n        return err(\"provide at least one case\");\n      }\n      const elseLen = len(otherwise);\n      let insCount =\n        args.reduce((acc, a) => acc + len(a), 0) +\n        (elseLen ? elseLen : 2) +\n        len(args);\n      const ins: ParserIns[] = cond;\n      while (len(args) > 1) {\n        const [a, when] = [args.shift()!, args.shift()!];\n        push(ins, a);\n        ins.push({ typ: \"mat\", value: len(when) + 1, errCtx });\n        push(ins, when);\n        insCount -= len(a) + len(when) + 2;\n        ins.push({ typ: \"jmp\", value: insCount, errCtx });\n      }\n      if (len(otherwise)) {\n        push(ins, otherwise);\n      } else {\n        ins.push({ typ: \"pop\", value: 1, errCtx });\n        ins.push({ typ: \"val\", value: falseVal, errCtx });\n      }\n      return ins;\n    } else if (op === \"catch\") {\n      if (len(nodes) < 2) {\n        return err(\"provide at least 2 arguments\");\n      } else if (isToken(nodes[0])) {\n        return err(\"argument 1 must be expression\");\n      }\n      const body = nodeParser(nodes[0]);\n      const when = flat(slice(nodes, 1).map(nodeParser));\n      return [...body, { typ: \"cat\", value: len(when), errCtx }, ...when];\n    } else if (op === \"and\" || op === \"or\" || op === \"while\") {\n      const args = nodes.map(nodeParser);\n      let insCount = args.reduce((acc, a) => acc + len(a), 0);\n      if (len(args) < 2) {\n        return err(\"provide at least 2 arguments\");\n      }\n      const ins: ParserIns[] = [];\n      if (op === \"while\") {\n        ins.push({ typ: \"val\", value: nullVal, errCtx }); //If first is false\n        insCount += 2; //+1 for the if ins, +1 for the pop ins\n        const [head, body] = [args[0], slice(args, 1)];\n        push(ins, head);\n        ins.push({ typ: \"if\", value: insCount - len(head), errCtx });\n        ins.push({ typ: \"pop\", value: len(body), errCtx });\n        push(ins, flat(body));\n        ins.push({ typ: \"loo\", value: -(insCount + 1), errCtx });\n        return ins;\n      }\n      insCount += len(args); //+1 for each if/or ins\n      insCount += toNum(op === \"and\");\n      const typ = op === \"and\" ? \"if\" : \"or\";\n      for (let a = 0; a < len(args); ++a) {\n        push(ins, args[a]);\n        insCount -= len(args[a]);\n        ins.push({ typ, value: insCount, errCtx });\n        --insCount;\n      }\n      if (op === \"and\") {\n        push(ins, [\n          { typ: \"val\", value: <Val>{ t: \"bool\", v: true }, errCtx },\n          { typ: \"jmp\", value: 1, errCtx },\n        ]);\n      }\n      ins.push({ typ: \"val\", value: falseVal, errCtx });\n      return ins;\n    } else if (op === \"var\" || op === \"let\") {\n      const defs = nodes.filter((n, i) => !(i % 2));\n      const vals = nodes.filter((n, i) => !!(i % 2));\n      if (!len(defs)) {\n        return err(\"provide at least 1 declaration name and value\");\n      } else if (len(defs) > len(vals)) {\n        return err(\"provide a value after each declaration name\");\n      }\n      const ins: ParserIns[] = [];\n      for (let d = 0, lim = len(defs); d < lim; ++d) {\n        push(ins, nodeParser(vals[d]));\n        const def = defs[d];\n        if (isToken(def)) {\n          const defIns = parseNode(defs[d], params);\n          if (len(defIns) > 1 || defIns[0].typ !== \"ref\") {\n            return err(\"declaration name must be symbol\", defIns[0].errCtx);\n          }\n          ins.push({ typ: op, value: defIns[0].value, errCtx });\n        } else {\n          const { shape, errors } = parseParams([def], true);\n          if (len(errors)) {\n            return errors;\n          }\n          const typ = op === \"var\" ? \"dva\" : \"dle\";\n          ins.push({ typ, value: shape, errCtx });\n        }\n      }\n      return ins;\n    } else if (op === \"var!\" || op === \"let!\") {\n      //Rewrite e.g. (var! a + 1) -> (var a (+ a 1))\n      if (len(nodes) < 2) {\n        return err(\"provide 1 declaration name and 1 function\");\n      }\n      const parsed = nodes.map(nodeParser);\n      const [def, func, args] = [parsed[0][0], parsed[1], slice(parsed, 2)];\n      if (def.typ !== \"ref\") {\n        return err(\"declaration name must be symbol\", def.errCtx);\n      }\n      const ins: Ins[] = [{ typ: \"ref\", value: def.value, errCtx }];\n      push(ins, [...flat(args), ...func]);\n      ins.push({ typ: \"exe\", value: len(args) + 1, errCtx });\n      const typ = op === \"var!\" ? \"var\" : \"let\";\n      ins.push({ typ, value: def.value, errCtx });\n      return ins;\n    } else if (op === \"#\" || op === \"@\" || op === \"fn\") {\n      const pins: ParserIns[] = [];\n      let asStr = node2str(nodes);\n      asStr = op === \"fn\" ? `(fn ${asStr})` : `${op}(${asStr})`;\n      if (op === \"fn\") {\n        const parsedParams = parseParams(nodes, false);\n        params = parsedParams.shape;\n        push(pins, parsedParams.errors);\n        if (!len(nodes)) {\n          return err(\"provide a body\");\n        }\n        nodes.unshift({ typ: \"sym\", text: \"do\", errCtx });\n      }\n      //Rewrite partial closure to #(... [body] args)\n      if (op === \"@\") {\n        nodes = [\n          { typ: \"sym\", text: \"...\", errCtx },\n          ...nodes,\n          { typ: \"sym\", text: \"args\", errCtx },\n        ];\n      }\n      push(pins, parseForm(nodes, params, op !== \"@\"));\n      const cins = <Ins[]>pins.filter(i => i.typ !== \"err\");\n      const errors = pins.filter(i => i.typ === \"err\");\n      if (len(errors)) {\n        return errors;\n      }\n      if (op === \"fn\") {\n        cins.forEach(i => {\n          if (i.typ === \"npa\") {\n            i.typ = \"upa\";\n          }\n        });\n      }\n      //Calculate captures\n      const captureIns: Ins[] = [];\n      const captured: boolean[] = [];\n      for (let i = 0; i < len(cins); ++i) {\n        const ci = cins[i];\n        const isExe =\n          ci.typ === \"val\" &&\n          i + 1 < len(cins) &&\n          cins[i + 1].typ === \"exe\" &&\n          ((ci.value.t === \"func\" && !ops[ci.value.v]) || ci.value.t === \"str\");\n        captured[i] =\n          (ci.typ === \"ref\" &&\n            !cins.find(i => i.typ === \"let\" && i.value === ci.value)) ||\n          ci.typ === \"npa\" ||\n          isExe;\n        if (captured[i]) {\n          captureIns.push(ci);\n        }\n      }\n      const value = { name: asStr, closureIns: cins, captureIns, captured };\n      return [{ typ: op === \"@\" ? \"par\" : \"clo\", value, errCtx }];\n    }\n\n    //Operation arity check, optionally disabled for partial closures\n    if (ops[op] && doArityCheck) {\n      const errors = arityCheck(op, len(nodes), errCtx);\n      const err = (value: string, eCtx = errCtx) => [\n        <ParserIns>{ typ: \"err\", value, errCtx: eCtx },\n      ];\n      push(head, errors?.map(e => err(e.m)[0]) ?? []);\n      if (!errors) {\n        //Upgrade some math and logic functions to their faster counterparts\n        if (len(nodes) === 2 && ops[`fast${op}`]) {\n          head = nodeParser({ typ: \"sym\", text: `fast${op}`, errCtx });\n        }\n      }\n    }\n  }\n\n  const args = nodes.map(nodeParser);\n  const ins: ParserIns[] = flat(args);\n  if (symAt([firstNode]) === \"return\") {\n    return [...ins, { typ: \"ret\", value: !!len(args), errCtx }];\n  } else if (head[0].typ === \"ref\") {\n    const { value: v, errCtx } = head[0];\n    head[0] = { typ: \"val\", value: { t: \"str\", v }, errCtx };\n  }\n  push(ins, head);\n  const typ = len(head) > 1 ? \"exa\" : \"exe\";\n  return [...ins, { typ, value: len(args), errCtx }];\n}\n\nfunction parseArg(node: Node, params: ParamsShape): ParserIns[] {\n  if (isToken(node)) {\n    const { errCtx } = node;\n    if (node.typ === \"str\") {\n      return [{ typ: \"val\", value: { t: \"str\", v: node.text }, errCtx }];\n    } else if (node.typ === \"num\") {\n      return [{ typ: \"val\", value: { t: \"num\", v: toNum(node.text) }, errCtx }];\n    } else if (node.typ === \"sym\") {\n      const { text } = node;\n      const paramNames = params.map(({ name }) => name);\n      if (text === \"true\" || text === \"false\") {\n        return [\n          { typ: \"val\", value: <Val>{ t: \"bool\", v: text === \"true\" }, errCtx },\n        ];\n      } else if (text === \"null\") {\n        return [{ typ: \"val\", value: nullVal, errCtx }];\n      } else if (text === \"_\") {\n        return [{ typ: \"val\", value: { t: \"wild\", v: undefined }, errCtx }];\n      } else if (starts(text, \":\")) {\n        return [{ typ: \"val\", value: <Val>{ t: \"key\", v: text }, errCtx }];\n      } else if (starts(text, \"%\") && isNum(substr(text, 1))) {\n        const value = toNum(substr(text, 1));\n        if (value < 0) {\n          return [{ typ: \"val\", value: nullVal, errCtx }];\n        }\n        return [{ typ: \"upa\", value, errCtx }];\n      } else if (has(paramNames, text)) {\n        const param = params.find(({ name }) => name === text)!;\n        if (len(param.position) === 1) {\n          return [{ typ: \"npa\", value: param.position[0], errCtx }];\n        }\n        return [{ typ: \"dpa\", value: param.position, errCtx }];\n      } else if (text === \"args\") {\n        return [{ typ: \"upa\", value: -1, errCtx }];\n      } else if (text === \"PI\" || text === \"E\") {\n        const v = text === \"PI\" ? 3.141592653589793 : 2.718281828459045;\n        return [{ typ: \"val\", value: { t: \"num\", v }, errCtx }];\n      } else if (ops[text]) {\n        return [{ typ: \"val\", value: <Val>{ t: \"func\", v: text }, errCtx }];\n      }\n      return [{ typ: \"ref\", value: text, errCtx }];\n    }\n    return [];\n  } else if (!len(node)) {\n    return [];\n  }\n  return parseForm(node, params);\n}\n\n/** Consumes some tokens and returns ParamsShape.\n * Example inputs:\n * \"(fn \"   a [b [c]] d [d c b a]\n * \"(var \" [a] [1 2] b [1 2]\n * \"(function \" [x] (print x) x\n * \"(function \" x [x]\n * \"(fn \"\n * \"(function \"\n * */\nfunction parseParams(\n  nodes: Node[],\n  consumeLast: boolean,\n  position: number[] = [],\n): { shape: ParamsShape; errors: ParserIns[] } {\n  const shape: ParamsShape = [],\n    errs: ParserIns[] = [];\n  let n = 0;\n  while (\n    len(nodes) > (consumeLast ? 0 : 1) &&\n    (isToken(nodes[0]) || symAt(nodes[0]) === \"vec\")\n  ) {\n    const param = nodes.shift()!;\n    if (!isToken(param)) {\n      param.shift();\n      const parsed = parseParams(param, true, [...position, n]);\n      push(shape, parsed.shape);\n      push(errs, parsed.errors);\n    } else {\n      const { typ, errCtx } = param;\n      if (typ === \"sym\") {\n        shape.push({ name: param.text, position: [...position, n] });\n      } else {\n        errs.push({ typ: \"err\", value: \"provide parameter name\", errCtx });\n      }\n    }\n    ++n;\n  }\n  return { shape, errors: errs };\n}\n\nfunction compileFunc({ name, nodes: nodes }: NamedNodes): Func | InvokeError {\n  const { shape: params, errors } = parseParams(nodes, false);\n  const ins = [...errors, ...flat(nodes.map(node => parseArg(node, params)))];\n  for (let i = 0, lim = len(ins); i < lim; i++) {\n    const { typ, value, errCtx } = ins[i];\n    if (typ === \"err\") {\n      return <InvokeError>{ e: \"Parse\", m: value, errCtx };\n    }\n  }\n  return { name, ins: <Ins[]>ins };\n}\n\nfunction findParenImbalance(\n  tokens: Token[],\n  numL: number,\n  numR: number,\n): [number, number] {\n  //Scan for first instance of untimely closed\n  //  or last instance of unclosed open\n  const untimely = numR >= numL;\n  const [l, r] = [untimely ? \"(\" : \")\", untimely ? \")\" : \"(\"];\n  const direction = untimely ? 1 : -1;\n  for (\n    let lim = len(tokens), t = untimely ? 0 : lim - 1, depth = 0;\n    untimely ? t < lim : t >= 0;\n    t += direction\n  ) {\n    const {\n      typ,\n      errCtx: { line, col },\n    } = tokens[t];\n    depth += toNum(typ === l) - toNum(typ === r);\n    if (depth < 0) {\n      return [line, col];\n    }\n  }\n  return [0, 0];\n}\n\nfunction tokenErrorDetect(stringError: number[] | undefined, tokens: Token[]) {\n  const invokeId = len(tokens) ? tokens[0].errCtx.invokeId : \"\";\n  const errors: InvokeError[] = [];\n  const err = (m: string, errCtx: ErrCtx) =>\n    errors.push({ e: \"Parse\", m, errCtx });\n\n  //Check for double-quote imbalance\n  if (stringError) {\n    const [line, col] = stringError;\n    err(\"unmatched double quotation marks\", { invokeId, line, col });\n    return errors;\n  }\n\n  //Check for paren imbalance\n  const countTyp = (t: Token[\"typ\"]) =>\n    len(tokens.filter(({ typ }) => typ === t));\n  const [numL, numR] = [countTyp(\"(\"), countTyp(\")\")];\n  {\n    const [line, col] = findParenImbalance(tokens, numL, numR);\n    if (line + col) {\n      err(\"unmatched parenthesis\", { invokeId: invokeId, line, col });\n    }\n  }\n\n  //Check for any empty expressions\n  let emptyHead: Token | undefined;\n  for (let t = 0, lastWasL = false; t < len(tokens); ++t) {\n    if (lastWasL && tokens[t].typ === \")\") {\n      emptyHead = tokens[t];\n      break;\n    }\n    lastWasL = tokens[t].typ === \"(\";\n  }\n  if (emptyHead) {\n    err(\"empty expression forbidden\", emptyHead.errCtx);\n  }\n\n  return errors;\n}\n\n//TODO: investigate Node implementation replacement\nfunction insErrorDetect(fins: Ins[]): InvokeError[] | undefined {\n  type TypeInfo = {\n    types?: Val[\"t\"][];\n    val?: Val;\n  };\n  const stack: TypeInfo[] = [];\n  for (let i = 0, lim = len(fins); i < lim; ++i) {\n    const ins = fins[i];\n    switch (ins.typ) {\n      case \"val\":\n        stack.push({ types: [ins.value.t], val: ins.value });\n        break;\n      case \"exa\":\n      case \"exe\": {\n        const head = stack.pop()!;\n        const args = splice(stack, len(stack) - ins.value, ins.value);\n        const badMatch = (okTypes: Val[\"t\"][]) =>\n          args.findIndex(\n            ({ types }) => types && !okTypes.find(t => has(types, t)),\n          );\n        const headIs = (t: Val[\"t\"]) =>\n          head.val\n            ? head.val.t === t\n            : head.types && len(head.types) === 1 && head.types[0] === t;\n        if (head.val && head.val.t === \"func\") {\n          if (head.val.v === \"recur\") {\n            splice(stack, len(stack) - ins.value, ins.value);\n            break;\n          }\n          const errors = typeCheck(\n            head.val.v,\n            args.map(a => a.types ?? []),\n            ins.errCtx,\n            true,\n          );\n          if (errors) {\n            return errors;\n          }\n          const { returns, numeric: onlyNum } = ops[head.val.v];\n          stack.push(\n            onlyNum && onlyNum !== \"in only\"\n              ? { types: [\"num\"] }\n              : { types: returns },\n          );\n        } else if (headIs(\"num\")) {\n          const badArg = badMatch([\"str\", \"dict\", \"vec\"]);\n          if (badArg !== -1) {\n            return numOpErr(ins.errCtx, args[badArg].types!);\n          }\n          stack.push({});\n        } else if (headIs(\"key\")) {\n          const badArg = badMatch([\"dict\", \"vec\"]);\n          if (badArg !== -1) {\n            return keyOpErr(ins.errCtx, args[badArg].types!);\n          }\n          stack.push({});\n        } else if (headIs(\"str\") || headIs(\"bool\")) {\n          stack.push({});\n        } else if (!head.types && !head.val) {\n          stack.push({});\n        }\n        break;\n      }\n      case \"or\":\n        stack.pop();\n        stack.push({});\n        i += ins.value;\n        break;\n      case \"cat\":\n      case \"var\":\n      case \"let\":\n      case \"dva\":\n      case \"dle\":\n      case \"loo\":\n      case \"jmp\":\n        break;\n      case \"clo\":\n      case \"par\": {\n        const errors = insErrorDetect(ins.value.closureIns);\n        if (errors) {\n          return errors;\n        }\n      }\n      case \"ref\":\n      case \"npa\":\n      case \"upa\":\n      case \"dpa\":\n        stack.push({});\n        break;\n      case \"if\": {\n        stack.pop();\n        stack.push({});\n        const ifIns = slice(fins, i + 1, ins.value + 1);\n        const errors = insErrorDetect(ifIns);\n        if (errors) {\n          return errors;\n        }\n        i += ins.value - 1;\n        break;\n      }\n      case \"mat\": {\n        stack.pop(); //first match\n        stack.pop(); //cond\n        i += ins.value;\n        i += fins[i].value as number; //The first jmp\n        stack.push({});\n        break;\n      }\n      case \"pop\":\n        splice(stack, len(stack) - ins.value, ins.value);\n        break;\n      case \"ret\":\n        if (ins.value) {\n          stack.pop();\n        }\n        break;\n      default:\n        assertUnreachable(ins);\n    }\n  }\n}\n\nexport function parse(\n  code: string,\n  invokeId: string,\n): { funcs: Funcs; errors: InvokeError[] } {\n  const { tokens, stringError } = tokenise(code, invokeId);\n  const tokenErrors = tokenErrorDetect(stringError, tokens);\n  if (len(tokenErrors)) {\n    return { errors: tokenErrors, funcs: {} };\n  }\n  const okFuncs: Func[] = [],\n    errors: InvokeError[] = [];\n  const tree = treeise(slice(tokens));\n  const collected = collectFuncs(tree);\n  const namedNodes: NamedNodes[] = [];\n  collected.forEach(nodeOrErr => {\n    if (\"err\" in nodeOrErr) {\n      errors.push({ e: \"Parse\", m: nodeOrErr.err, errCtx: nodeOrErr.errCtx });\n    } else {\n      namedNodes.push({ name: nodeOrErr.name, nodes: nodeOrErr.nodes });\n    }\n  });\n  namedNodes.map(compileFunc).forEach(fae => {\n    if (\"e\" in fae) {\n      errors.push(fae);\n    } else {\n      okFuncs.push(fae);\n    }\n  });\n  push(errors, flat(okFuncs.map(f => insErrorDetect(f.ins) ?? [])));\n  const funcs: Funcs = {};\n  okFuncs.forEach(func => (funcs[func.name ?? \"\"] = func));\n  return { errors, funcs };\n}\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","toNum","x","Number","slice","arr","start","end","splice","numDel","length","slen","str","isNum","isNaN","Array","isArray","substr","substring","strIdx","idx","sub","s","includes","subIdx","indexOf","y","starts","prefix","startsWith","ends","endsWith","flat","concat","a","b","push","add","sortBy","by","sort","reverse","lowerCase","toLowerCase","upperCase","toUpperCase","trim","trimStart","trimEnd","padEnd","charCode","charCodeAt","codeChar","num","String","fromCharCode","randNum","Math","random","randInt","floor","range","keys","objKeys","getTimeMs","Date","getTime","abs","min","max","sin","cos","tan","sqrt","round","ceil","sign","logn","log","log2","log10","has","len","tokenise","code","invokeId","makeCollsOps","emitComments","tokens","isDigit","ch","inString","line","col","inStringAt","inSymbol","inNumber","inHex","i","l","c","nextCh","text","n","t","r","errCtx","typ","isWhite","nl","isParen","hexStart","stringError"],"sourceRoot":""}